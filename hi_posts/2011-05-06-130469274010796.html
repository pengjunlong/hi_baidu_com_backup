---
layout: post
title: global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来
time: 2011-05-06 22:39
tags: 好好学习天天向上
---

<div id=content class="content mod-cs-content text-content clearfix"> <p>用法: grep [选项]... PATTERN [FILE]...<br />在每个 FILE 或是标准输入中查找 PATTERN。<br />默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。<br />例如: grep -i 'hello world' menu.h main.c<br /><br />正则表达式选择与解释:<br />&nbsp; -E, --extended-regexp&nbsp;&nbsp;&nbsp;&nbsp; PATTERN 是一个可扩展的正则表达式(缩写为 ERE)<br />&nbsp; -F, --fixed-strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PATTERN 是一组由断行符分隔的定长字符串。<br />&nbsp; -G, --basic-regexp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PATTERN 是一个基本正则表达式(缩写为 BRE)<br />&nbsp; -P, --perl-regexp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PATTERN 是一个 Perl 正则表达式<br />&nbsp; -e, --regexp=PATTERN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用 PATTERN 来进行匹配操作<br />&nbsp; -f, --file=FILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从 FILE 中取得 PATTERN<br />&nbsp; -i, --ignore-case&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 忽略大小写<br />&nbsp; -w, --word-regexp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 强制 PATTERN 仅完全匹配字词<br />&nbsp; -x, --line-regexp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 强制 PATTERN 仅完全匹配一行<br />&nbsp; -z, --null-data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一个 0 字节的数据行，但不是空行<br /><br />Miscellaneous:<br />&nbsp; -s, --no-messages&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; suppress error messages<br />&nbsp; -v, --invert-match&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select non-matching lines<br />&nbsp; -V, --version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print version information and exit<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --help&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; display this help and exit<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --mmap&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ignored for backwards compatibility<br /><br />Output control:<br />&nbsp; -m, --max-count=NUM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stop after NUM matches<br />&nbsp; -b, --byte-offset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print the byte offset with output lines<br />&nbsp; -n, --line-number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print line number with output lines<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --line-buffered&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flush output on every line<br />&nbsp; -H, --with-filename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print the filename for each match<br />&nbsp; -h, --no-filename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; suppress the prefixing filename on output<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --label=LABEL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print LABEL as filename for standard input<br />&nbsp; -o, --only-matching&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; show only the part of a line matching PATTERN<br />&nbsp; -q, --quiet, --silent&nbsp;&nbsp;&nbsp;&nbsp; suppress all normal output<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --binary-files=TYPE&nbsp;&nbsp; assume that binary files are TYPE;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TYPE is `binary', `text', or `without-match'<br />&nbsp; -a, --text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; equivalent to --binary-files=text<br />&nbsp; -I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; equivalent to --binary-files=without-match<br />&nbsp; -d, --directories=ACTION&nbsp; how to handle directories;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACTION is `read', `recurse', or `skip'<br />&nbsp; -D, --devices=ACTION&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; how to handle devices, FIFOs and sockets;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACTION is `read' or `skip'<br />&nbsp; -R, -r, --recursive&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; equivalent to --directories=recurse<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --include=FILE_PATTERN&nbsp; search only files that match FILE_PATTERN<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --exclude=FILE_PATTERN&nbsp; skip files and directories matching FILE_PATTERN<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --exclude-from=FILE&nbsp;&nbsp; skip files matching any file pattern from FILE<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --exclude-dir=PATTERN&nbsp; directories that match PATTERN will be skipped.<br />&nbsp; -L, --files-without-match&nbsp; print only names of FILEs containing no match<br />&nbsp; -l, --files-with-matches&nbsp; print only names of FILEs containing matches<br />&nbsp; -c, --count&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print only a count of matching lines per FILE<br />&nbsp; -T, --initial-tab&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; make tabs line up (if needed)<br />&nbsp; -Z, --null&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print 0 byte after FILE name<br /><br />Context control:<br />&nbsp; -B, --before-context=NUM&nbsp; print NUM lines of leading context<br />&nbsp; -A, --after-context=NUM&nbsp;&nbsp; print NUM lines of trailing context<br />&nbsp; -C, --context=NUM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print NUM lines of output context<br />&nbsp; -NUM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; same as --context=NUM<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --color[=WHEN],<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --colour[=WHEN]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use markers to highlight the matching strings;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHEN is `always', `never', or `auto'<br />&nbsp; -U, --binary&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; do not strip CR characters at EOL (MSDOS)<br />&nbsp; -u, --unix-byte-offsets&nbsp;&nbsp; report offsets as if CRs were not there (MSDOS)<br /><br />‘egrep’即‘grep -E’。‘fgrep’即‘grep -F’。<br />直接使用‘egrep’或是‘fgrep’均已不可行了。<br />不带 FILE 参数，或是 FILE 为 -，将读取标准输入。如果少于两个 FILE 参数<br />就要默认使用 -h 参数。如果选中任意一行，那退出状态为 0，否则为 1；<br />如果有错误产生，且未指定 -q 参数，那退出状态为 2。<br /><br />汇报错误到： bug-grep@gnu.org<br />GNU Grep 主页: &lt;http://www.gnu.org/software/grep/&gt;<br />GNU 软件的通用帮助: &lt;http://www.gnu.org/gethelp/&gt;<br /></p> </div>
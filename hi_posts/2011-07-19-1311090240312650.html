---
layout: post
title: strlen源码剖析
time: 2011-07-19 23:44
tags: 好好学习天天向上
---

<div id=content class="content mod-cs-content text-content clearfix"> 1&nbsp;size_t&nbsp;strlen_b(const&nbsp;char&nbsp;*          str)&nbsp;{<br />      2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*cp&nbsp;=          &nbsp;str;<br />      3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(*cp++          )<br />      4&nbsp;          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;<br />      5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(cp&nbsp;-&nbsp;str&nbsp;-&nbsp;1          );<br /><p>      6&nbsp;}</p><strong>2. 高效实现</strong>    <br />很显然，标准库的实现肯定不会如此简单，上面的strlen_a以及strlen_b都是一次判断一个字符直到发现'\0'为止，这是非常低效的。比较高效的实现如下(在这里WORD表示计算机中的一个字，不是WORD类型)：<br />(1) 一次判断一个字符直到内存对齐，如果在内存对齐之前就遇到'\0'则直接return，否则到(2)；<br />(2) 一次读入并判断一个WORD，如果此WORD中没有为0的字节，则继续下一个WORD，否则到(3)；<br />(3) 到这里则说明WORD中至少有一个字节为0，剩下的就是找出第一个为0的字节的位置然后return。<br /><br /><strong>NOTE：<br /></strong>数据对齐(<em>data alignment</em>)，是指数据所在的内存地址必须是该数据长度的整数倍，这样CPU的存取速度最快。比如在32位的计算机中，一个WORD为4 byte，则WORD数据的起始地址能被4整除的时候CPU的存取效率比较高。CPU的优化规则大概如下：对于n字节(n = 2,4,8...)的元素，它的首地址能被n整除才能获得最好的性能。<br /><br /><p>为了便于下面的讨论，这里假设所用的计算机为32位，即一个WORD为4个字节。下面给出在32位计算机上的C语言实现(假设unsigned long为4个字节)：</p>第24行的if语句是整个算法的核心，该语句判断22行读入的WORD中是否有为0的字节<br />if&nbsp;((((longword&nbsp;+&nbsp;magic_bits)&nbsp;^&nbsp;~longword)&nbsp;&amp;&nbsp;~magic_bits)&nbsp;!=&nbsp;0)if语句中的计算可以分为如下3步：<br />(1) longword + magic_bits<br />其中magic_bits的二进制表示如下：<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;31-------------------------------&gt;0<br />&nbsp;&nbsp;magic_bits:&nbsp;01111110&nbsp;11111110&nbsp;11111110&nbsp;11111111<br />magic_bits中的31,24,16,8这些bits都为0，我们把这几个bits称为holes，注意在每个byte的左边都有一个hole。<br /><br />检测0字节：<br />如果longword 中有一个字节的所有bit都为0，则进行加法后，从这个字节的右边的字节传递来的进位都会落到这个字节的最低位所在的hole上，而从这个字节的最高位则永远不会产生向左边字节的hole的进位。则这个字节左边的hole在进行加法后不会改变，由此可以检测出0字节；相反，如果longword中所有字节都不为0，则每个字节中至少有1位为1，进行加法后所有的hole都会被改变。<br /><br />为了便于理解，请看下面的例子：<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b0<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;31-------------------------------&gt;0<br />&nbsp;&nbsp;longword:&nbsp;&nbsp;&nbsp;XXXXXXXX&nbsp;XXXXXXXX&nbsp;00000000&nbsp;XXXXXXXX<br />+&nbsp;magic_bits:&nbsp;01111110&nbsp;11111110&nbsp;11111110&nbsp;11111111上面longword中的b1为0，X可能为0也可能为1。因为b1的所有bit都为0，而从b0传递过来的进位只可能是0或1，很显然b1永远也不会产生进位，所以加法后longword的第16 bit这个hole不会变。 </div>
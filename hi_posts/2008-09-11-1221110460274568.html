---
layout: post
title: TFTP编程之总结篇
time: 2008-09-11 13:21
tags: 
---

<div id=content class="content mod-cs-content text-content clearfix"> <p> </p><p><a href="http://baike.baidu.com/view/160411.htm" target="_blank">冒天下之大不韪</a></p><p><a href="http://hi.baidu.com/pengjunlong/blog/item/a676acfdc47b471009244db5.html">TFTP编程之服务器篇TftpS.cpp</a></p><p><a href="http://hi.baidu.com/pengjunlong/blog/item/4a94ac002cedad81e950cdb6.html">TFTP编程之服务器篇define.h</a></p><p><a href="http://hi.baidu.com/pengjunlong/blog/item/e0937d09b123e7c93bc763b6.html">TFTP编程之服务器篇log.h</a></p><p><a href="http://hi.baidu.com/pengjunlong/blog/item/957c78d912cdc02a11df9bb7.html">TFTP编程之服务器篇makepack.h</a></p><p><a href="http://hi.baidu.com/pengjunlong/blog/item/382bd3170921f00fc93d6db7.html">TFTP编程之客户机篇client.cpp</a></p><p><a href="http://hi.baidu.com/pengjunlong/blog/item/2cb6aa513d06111e367abeb0.html">TFTP编程之客户机篇cmdfunction.h</a></p><p><a href="http://hi.baidu.com/pengjunlong/blog/item/e374971034c9ae07213f2eb0.html">TFTP编程之客户机篇cmdprocess.h</a></p><p><a href="http://hi.baidu.com/pengjunlong/blog/item/d8bda3124bdc54c8c3fd78b0.html">TFTP编程之客户机篇define.h</a></p><p><a href="http://hi.baidu.com/pengjunlong/blog/item/21a47163f705fc660c33fab1.html">TFTP编程之客户机篇makepack.h</a></p><p><strong style="">客户端与服务器都是首先调用socket（）函数建立套接字，然后调用sendto（）与recvfrom（）函数分别发送或接收数据，最后调用closesocket（）函数关闭套接字。但是，服务器在发送与接收数据之前，还需要调用bind（）函数将某个端口与套接字相绑定。</strong></p><p>系统实现TFTP Server及TFTP client，可收文件，可发文件，可处理 size=0 ,size%512=0的文件，可处理 size&gt;3355920 Byte的文件（65535*512），有丢包处理，进行实时跟踪，有Log记录，差错处理(mode 错，文件不存在，…)...</p><p>①&nbsp;&nbsp;&nbsp;&nbsp;  系统任何传输起自一个读取或写入文件的请求，这个请求也是<strong style="">连接请求</strong>，请求后服务器将向客户端发送输入用户名的请求，如果正确则继续。</p><p>②&nbsp;&nbsp;&nbsp;&nbsp;  每个数据包包括一块数据，数据以定长512字节传输，服务器发出下一个数据包以前必须得到客户对上一个<strong style="">数据包</strong>的确认。如果一个数据包的大小小于512字节，则表示传输结束。</p><p>③&nbsp;&nbsp;&nbsp;&nbsp;  如果数据包在传输过程中丢失，发出方会在<strong style="">超时</strong>后重新传输最后一个未被确认的数据包。通信的双方都是数据的发出者与接收者，一方传输数据接收应答，另一方发出应答接收数据。</p><p>④&nbsp;&nbsp;&nbsp;&nbsp;  大部分的错误将会导致连接中断，错误由一个错误的数据包引起。这个包不会被确认，也不会被重新发送，因此另一方无法接收到。如果错误包丢失，则使用超时机制。<strong style="">错误</strong>主要是由下面三种情况引起的：不能满足请求，收到的数据包内容错误，而这种错误不能由延时或重发解释，对需要资源的访问丢失（如硬盘满）。</p><p>⑤&nbsp;&nbsp;&nbsp;&nbsp;  初始连接时候需要发出WRQ（请求写入）或RRQ（请求读取），收到一个确定应答，一个确定可以写出的包或应该读取的第一块数据。通常确认包包括要确认的包的包号，每个数据包都与一个块号相对应，块号从1开始而且是连续的。因此对于写入请求的确定是一个比较特殊的情况，因此它的包的包号是0。如果收到的包是一个错误的包，则这个请求被拒绝。</p><p>⑥&nbsp;&nbsp;&nbsp;&nbsp;  TFTP支持五种类型的包：</p><p>opcode   operation（Opcode）</p><p>1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  RRQ：Read request</p><p>2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  WRQ：Write request</p><p>3 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  DATA：Data</p><p>4 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ACK：Acknowledgment</p><p>5 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ERROR：Error</p><p>包头中包括了这个包所指定的操作码。</p><p>Figure 1:  RRQ/WRQ包</p><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  2 bytes &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 byte  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 byte</p><p>-------------------------------------------------</p><p>|&nbsp;&nbsp;  Opcode &nbsp;&nbsp;| Filename |&nbsp;&nbsp;  0&nbsp;&nbsp;  |  Mode |&nbsp;&nbsp;  0 &nbsp;&nbsp;|</p><p>-------------------------------------------------</p><p>RRQ和WRQ包（代码分别为1和2）的格式如上所示。文件名是NETASCII码字符，以0结束。 而MODE域包括了字符串&quot;netascii&quot;，&quot;octet&quot;或&quot;mail&quot;，名称不分大小写。接收到NETASCII格式数据的主机必须将数据转换为本地格式。OCTET模式用于传输文件，这种文件在源机上以8位格式存储。如果机器收到OCTET格式文件，返回时必须与原来文件完全一样。我们的实现建立在发送方和接收方都在相同模式（octet）的情况下。</p><p>Figure 2: DATA包</p><p>  2 bytes &nbsp;&nbsp;&nbsp;2 bytes &nbsp;&nbsp;&nbsp;n bytes（n〈=512）</p><p>-------------------------------------</p><p>|  Opcode  |  Block # | &nbsp;&nbsp;&nbsp;Data   &nbsp;&nbsp;|</p><p>-------------------------------------</p><p>数据在数据包中传输，其格式如上图所示。数据包的代码为3，它还包括有一个数据块号和数据。数据块号域从1开始编码，每个数据块依次加1，这样接收方可以确定这个包是新数据还是已经接收过的数据。数据域从0字节到512字节。如果数据域是512字节则它不是最后一个包，如果小于512字节则表示这个包是最后一个包。除了ACK和用于中断的包外，其它的包均得到确认。发出新的数据包等于确认上次的包。WRQ和DATA包由ACK或ERROR数据包确认，而RRQ数据包由DATA或ERROR数据包确认。WRQ数据包被ACK数据包确认，WRQ数据包的包号为0。</p><p>Figure 3: ACK包</p><p>  2 bytes&nbsp;&nbsp;   2 bytes</p><p>-----------------------</p><p>|  Opcode  |  Block # |</p><p>-----------------------</p><p>ACK包的操作码为4，其中的包号为要确认的数据包的包号。</p><p>Figure 4: ERROR包</p><p>  2 bytes &nbsp;&nbsp;&nbsp;&nbsp;2 bytes &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1 byte</p><p>-------------------------------------------</p><p>|  Opcode  |  ErrorCode  | &nbsp;&nbsp;ErrMsg &nbsp;&nbsp;| 0 |</p><p>-------------------------------------------</p><p>ERROR包的操作码是5，它的格式如上所示。此包可以被其它任何类型的包确认。错误码指定错误的类型。还可以附带错误信息。</p> </div>
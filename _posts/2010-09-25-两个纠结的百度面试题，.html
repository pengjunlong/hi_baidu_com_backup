tag=好好学习天天向上
<div id=content class="content mod-cs-content text-content clearfix"> 一.你现在有一个文件，文件中顺序存有N个记录，R1,R2,...,RN,这些记录不是有序的，但是你知道一个整数M,这些记录满足R1&lt;R2&lt;...&lt;RM以及RM+1&lt;RM+2&lt;...RN.<br />1,设计一个算法或编写一个程序，将文件中的记录排序为R1'&lt;R2',&lt;…&lt;,RN',算法或程序读取文件的次数为O(N),不限内存使用，<br />2,设计一个算法或编写一个程序，将文件中的记录排序为R1'&lt;R2'&lt;...&lt;RN',算法或程序读写文件的次数为O(N)，空间复杂度为O(1)，(亦即，你使用的内存大小和M,N均无关。)<br /><br />二 现有一组共计N个固定的集合（N为万量级），每个集合有个从0开始递增的集合ID，每个集合包含1~M个TERM（M为0~100的量级），希望设计一个程序能够持续对外服务，输入是一个<br />TERM数组，输出其中任意一个集合ID（如果该TERM数组包含该集合的所有TERM），如果找<br />不到输出-1。要求：<br />1， 时间复杂度最优，能够在短时间内对大量输入逐个输出<br />2， 实现具体的代码（可以是伪代码），其中常用的数据结构可以采用标准库。<br />3， 给出时间复杂度和空间复杂度。<br />TERM组合集合的文件格式举例：<br />TERM_1 空格 TERM_2<br />TERM_1 空格 TERM_3<br />TERM_1 空格 TERM_3 TERM_4<br />输入的为TERM数组（说明：TERM为一个词，可能是中文，固定字符串表示）<br /><br /><br /><br /><br /><br />对于上面的两个问题，第一个问题的，第1问，我感觉利用归并排序就可以了，但是对于第二问限制了，空间复杂度了，就想不明白了，感觉利用一些数组之间位置的转化，好像就可以，但是不知道具体的实现怎么来处理。<br /><br />对于第二个，问题，我感觉，首先将集合中的trem进行去重处理，之后在用每一个集合中term去查找，TERM数组，看看是否在当前的数组当中，一旦所有的都存在就可以了，<br /><br /><br />我的思路实现起来比较简单，但是感觉并不是很好，大家有什么更好的想法，拿出来讨论一下。<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />第一题：<br />1.归并排序<br />2.就地归并排序<br />第二题：<br />倒排<br /><br /><br />就地归并排序：<br />C/C++ code<br />#include &lt;stdio.h&gt;<br />#include &lt;iostream&gt;<br /><br />using namespace std;<br /><br />//int array[] = {1, 3, 5, 7, 2, 4, 6, 8};<br />int array[] = {3,5,7,8,1,2,4,6};<br />void display(int array[], int n)<br />{<br />for (int i = 0; i &lt; n; ++i)<br />{<br />printf(&quot;%d &quot;, array[i]);<br />}<br />printf(&quot;\n&quot;);<br />}<br /><br />/**<br />* 算法: 交换二对象<br />**/<br />template&lt;typename T&gt;<br />void t_swap( T&amp; v1, T&amp; v2 )<br />{<br />T t = v1; v1 = v2; v2 = t;<br />}<br /><br />/**<br />* 算法: 反转序列<br />**/<br />template&lt;typename T&gt;<br />void t_reverse( T* v, size_t size )<br />{<br />size_t s = 0, e = size-1;<br />while( s &lt; e &amp;&amp; s &lt; size &amp;&amp; e &gt; 0 )<br />t_swap( v[s++], v[e--] );<br />}<br /><br />/**<br />* 算法: 手摇算法,从指定位置旋转序列(见编程珠玑第二章)<br />**/<br />template&lt;typename T&gt;<br />void t_exchange( T* v, size_t size, size_t n )<br />{<br />t_reverse( v, n );<br />t_reverse( v + n, size - n );<br />t_reverse( v, size );<br />}<br /><br />/**<br />* 算法: 合并二已排序的连续序列<br />**/<br />template&lt;typename T&gt;<br />void t_merge( T&amp; v, size_t size, size_t pos )<br />{<br />size_t fir = 0, sec = pos;<br />while ( fir &lt; sec &amp;&amp; sec &lt; size )<br />{<br />while ( fir &lt; sec &amp;&amp; v[fir] &lt;= v[sec] ) fir++;<br />size_t maxMove = 0;<br />while ( sec &lt; size &amp;&amp; v[fir] &gt; v[sec] ) maxMove++, sec++;<br />t_exchange( &amp;v[fir], sec - fir, sec - fir - maxMove );<br />fir += maxMove;<br /><br />display(array, sizeof(array)/sizeof(int));<br />}<br />}<br /><br />/**<br />* 算法: 归并排序<br />**/<br />template&lt;typename T&gt;<br />void t_merge_sort( T* v, size_t size )<br />{<br />if ( size &lt;= 1 ) return;<br />t_merge_sort( v, size/2 );<br />t_merge_sort( v + size/2, size - size/2 );<br />t_merge( v, size, size/2 );<br />}<br /><br />int main()<br />{<br />display(array, sizeof(array)/sizeof(int));<br /><br />t_merge(array, sizeof(array) / sizeof(int), (sizeof(array)/sizeof(int))/2);<br />//t_merge_sort(array, sizeof(array) / sizeof(int));<br /><br />display(array, sizeof(array)/sizeof(int));<br />return 0;<br />} </div>
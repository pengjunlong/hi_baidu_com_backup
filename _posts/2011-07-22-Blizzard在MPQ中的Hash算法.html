<h2>好好学习天天向上</h2><br/><h1>Blizzard在MPQ中的Hash算法</h1><hr/>
<div id=content class="content mod-cs-content text-content clearfix"> <p>下面看看在MPQ中的Hash算法：</p><p><strong>函数一、</strong>以下的函数生成一个长度为0x500（合10进制数：1280）的cryptTable[0x500]</p><p>void prepareCryptTable()<br />{ <br />&nbsp;&nbsp;&nbsp; unsigned long seed = 0x00100001, index1 = 0, index2 = 0, i;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp; for( index1 = 0; index1 &lt; 0x100; index1++ )<br />&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for( index2 = index1, i = 0; i &lt; 5; i++, index2 += 0x100 )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned long temp1, temp2;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seed = (seed * 125 + 3) % 0x2AAAAB;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp1 = (seed &amp; 0xFFFF) &lt;&lt; 0x10;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seed = (seed * 125 + 3) % 0x2AAAAB;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; temp2 = (seed &amp; 0xFFFF);<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cryptTable[index2] = ( temp1 | temp2 ); <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp; } <br />}&nbsp;</p><p><strong>函数二、</strong>以下函数计算lpszFileName 字符串的hash值，其中dwHashType 为hash的类型，在下面的<strong>函数三</strong>、GetHashTablePos函数中调用此函数二，其可以取的值为0、1、2；该函数返回lpszFileName 字符串的hash值：&nbsp;</p><p>unsigned long <strong>HashString</strong>( char *lpszFileName, unsigned long dwHashType )<br />{ <br />&nbsp;&nbsp;&nbsp; unsigned char *key&nbsp; = (unsigned char *)lpszFileName;<br />unsigned long seed1 = 0x7FED7FED;<br />unsigned long seed2 = 0xEEEEEEEE;<br />&nbsp;&nbsp;&nbsp; int ch;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp; while( *key != 0 )<br />&nbsp;&nbsp;&nbsp; { <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ch = toupper(*key++);<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seed1 = cryptTable[(dwHashType &lt;&lt; 8) + ch] ^ (seed1 + seed2);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seed2 = ch + seed1 + seed2 + (seed2 &lt;&lt; 5) + 3; <br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; return seed1; <br />}</p><p><br />&nbsp;&nbsp;&nbsp; Blizzard的这个算法是非常高效的，被称为&quot;One-Way Hash&quot;( A one-way hash is a an algorithm that is constructed in such a way that deriving the original string (set of strings, actually) is virtually impossible)。举个例子，字符串&quot;unitneutralacritter.grp&quot;通过这个算法得到的结果是0xA26067F3。</p><p>　　是不是把第一个算法改进一下，改成逐个比较字符串的Hash值就可以了呢，答案是，远远不够，要想得到最快的算法，就不能进行逐个的比较，通常是构造一个<strong>哈希表</strong>(Hash Table)来解决问题，哈希表是一个大数组，这个数组的容量根据程序的要求来定义，例如1024，每一个Hash值通过取模运算 (mod) 对应到数组中的一个位置，这样，只要比较这个字符串的哈希值对应的位置有没有被占用，就可以得到最后的结果了，想想这是什么速度？是的，是最快的O(1)，现在仔细看看这个算法吧：</p><p>typedef struct<br />{<br />&nbsp;&nbsp;&nbsp; int nHashA;<br />&nbsp;&nbsp;&nbsp; int nHashB;<br />&nbsp;&nbsp;&nbsp; char bExists;<br />&nbsp;&nbsp; ......<br />} SOMESTRUCTRUE;<br />一种可能的结构体定义？</p><p><strong>函数三、</strong>下述函数为在Hash表中查找是否存在目标字符串，有则返回要查找字符串的Hash值，无则，return -1.</p><p>int <strong>GetHashTablePos</strong>( har *lpszString, SOMESTRUCTURE *lpTable ) <br />//lpszString要在Hash表中查找的字符串，lpTable为存储字符串Hash值的Hash表。<br />{ <br />&nbsp;&nbsp;&nbsp; int nHash = HashString(lpszString);&nbsp; //调用上述函数二，返回要查找字符串lpszString的Hash值。<br />&nbsp;&nbsp;&nbsp; int nHashPos = nHash % nTableSize;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp; if ( lpTable[nHashPos].bExists&nbsp; &amp;&amp;&nbsp; !strcmp( lpTable[nHashPos].pString, lpszString ) ) <br />&nbsp;&nbsp;&nbsp; {&nbsp; //如果找到的Hash值在表中存在，且要查找的字符串与表中对应位置的字符串相同，<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nHashPos;&nbsp;&nbsp;&nbsp; //则返回上述调用函数二后，找到的Hash值<br />&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -1;&nbsp; <br />&nbsp;&nbsp;&nbsp; } <br />}</p><p>&nbsp;<br />&nbsp;&nbsp;&nbsp; 看到此，我想大家都在想一个很严重的问题：“如果两个字符串在哈希表中对应的位置相同怎么办？”,毕竟一个数组容量是有限的，这种可能性很大。解决该问题的方法很多，我首先想到的就是用“<strong>链表</strong>”,感谢大学里学的数据结构教会了这个百试百灵的法宝，我遇到的很多算法都可以转化成链表来解决，只要在哈希表的每个入口挂一个链表，保存所有对应的字符串就OK了。事情到此似乎有了完美的结局，如果是把问题独自交给我解决，此时我可能就要开始定义数据结构然后写代码了。</p><p>&nbsp;&nbsp;&nbsp; 然而Blizzard的程序员使用的方法则是更精妙的方法。基本原理就是：他们在哈希表中不是用一个哈希值而是用<strong>三个哈希值</strong>来校验字符串。</p><p>&nbsp;</p><p>&nbsp;&nbsp;&nbsp; MPQ使用文件名哈希表来跟踪内部的所有文件。但是这个表的格式与正常的哈希表有一些不同。首先，它没有使用哈希作为下标，把实际的文件名存储在表中用于验证，实际上它根本就没有存储文件名。而是使用了3种不同的哈希：一个用于哈希表的下标，两个用于验证。这两个验证哈希替代了实际文件名。<br />&nbsp;&nbsp;&nbsp; 当然了，这样仍然会出现2个不同的文件名哈希到3个同样的哈希。但是这种情况发生的概率平均是：1:18889465931478580854784，这个概率对于任何人来说应该都是足够小的。现在再回到数据结构上，Blizzard使用的哈希表没有使用链表，而采用&quot;顺延&quot;的方式来解决问题，看看这个算法：</p><p><strong>函数四、</strong>lpszString 为要在hash表中查找的字符串；lpTable 为存储字符串hash值的hash表；nTableSize 为hash表的长度：&nbsp;</p><p>int <strong>GetHashTablePos</strong>( char *lpszString, MPQHASHTABLE *lpTable, int nTableSize )<br />{<br />&nbsp;&nbsp;&nbsp; const int&nbsp; HASH_OFFSET = 0, HASH_A = 1, HASH_B = 2;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp; int&nbsp; nHash = HashString( lpszString, HASH_OFFSET );<br />&nbsp;&nbsp;&nbsp; int&nbsp; nHashA = HashString( lpszString, HASH_A );<br />&nbsp;&nbsp;&nbsp; int&nbsp; nHashB = HashString( lpszString, HASH_B );<br />&nbsp;&nbsp;&nbsp; int&nbsp; nHashStart = nHash % nTableSize;<br />&nbsp;&nbsp;&nbsp; int&nbsp; nHashPos = nHashStart;<br />&nbsp;<br />&nbsp;&nbsp;&nbsp; while ( lpTable[nHashPos].bExists )<br />&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp; /*如果仅仅是判断在该表中时候存在这个字符串，就比较这两个hash值就可以了，不用对<br />&nbsp;&nbsp;&nbsp;&nbsp; *结构体中的字符串进行比较。这样会加快运行的速度？减少hash表占用的空间？这种<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *方法一般应用在什么场合？*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( 　 lpTable[nHashPos].nHashA == nHashA<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp;&nbsp; lpTable[nHashPos].nHashB == nHashB )<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return nHashPos;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nHashPos = (nHashPos + 1) % nTableSize;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (nHashPos == nHashStart)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; return -1;<br />}</p><p>上述程序解释：</p><p>计算出字符串的三个哈希值（一个用来确定位置x，另外两个用来校验)，下面为循环<br /><u><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x为空，则肯定该字符串不存在，返回-1。<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x不为空，则检查其他两个哈希值是否也匹配</strong></u></p><p><u><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果匹配，则表示找到了该字符串，返回x<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 不匹配，x++</strong></u></p><p><u><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果已经移到了表的末尾，则反绕到表的开始位置起继续查询　<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果回到了原来的位置，返回-1</strong></u></p> </div>
---
layout: post
title: 快速排序stdlib/qsort.c
time: 2011-03-10 10:35
tags: 好好学习天天向上
---

<div id=content class="content mod-cs-content text-content clearfix"> <p>/*&nbsp;Copyright (C) 1991,1992,1996,1997,1999,2004 Free Software Foundation, Inc.<br />&nbsp;&nbsp; This file is part of the GNU C Library.<br />&nbsp;&nbsp; Written by Douglas C. Schmidt (schmidt@ics.uci.edu).<br /><br />&nbsp;&nbsp; The GNU C Library is free software; you can redistribute it and/or<br />&nbsp;&nbsp; modify it under the terms of the GNU Lesser General Public<br />&nbsp;&nbsp; License as published by the Free Software Foundation; either<br />&nbsp;&nbsp; version 2.1 of the License, or (at your option) any later version.<br /><br />&nbsp;&nbsp; The GNU C Library is distributed in the hope that it will be useful,<br />&nbsp;&nbsp; but WITHOUT ANY WARRANTY; without even the implied warranty of<br />&nbsp;&nbsp; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&nbsp;&nbsp;See the GNU<br />&nbsp;&nbsp; Lesser General Public License for more details.<br /><br />&nbsp;&nbsp; You should have received a copy of the GNU Lesser General Public<br />&nbsp;&nbsp; License along with the GNU C Library; if not, write to the Free<br />&nbsp;&nbsp; Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA<br />&nbsp;&nbsp; 02111-1307 USA.&nbsp;&nbsp;*/<br /><br />/*&nbsp;If you consider tuning this algorithm, you should consult first:<br />&nbsp;&nbsp; Engineering a sort function; Jon Bentley and M. Douglas McIlroy;<br />&nbsp;&nbsp; Software - Practice and Experience; Vol. 23 (11), 1249-1265, 1993.&nbsp;&nbsp;*/<br /><br />#include&lt;alloca.h&gt;<br />#include&lt;limits.h&gt;<br />#include&lt;stdlib.h&gt;<br />#include&lt;string.h&gt;<br /><br />/*&nbsp;Byte-wise swap two items of size SIZE.*/<br />#define SWAP(a, b, size)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br />&nbsp;&nbsp;do&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;register&nbsp;size_t&nbsp;__size = (size);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;register&nbsp;char&nbsp;*__a = (a), *__b = (b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;__tmp = *__a;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*__a++ = *__b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*__b++ = __tmp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}while&nbsp;(--__size &gt;0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \<br />&nbsp;&nbsp;&nbsp;&nbsp;}while&nbsp;(0)<br /><br />/*&nbsp;Discontinue quicksort algorithm when partition gets below this size.<br />&nbsp;&nbsp; This particular magic number was chosen to work best on a Sun 4/260.*/<br />#define MAX_THRESH4<br /><br />/*&nbsp;Stack node declarations used to store unfulfilled partition obligations.*/<br />typedef&nbsp;struct<br />&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*lo;<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*hi;<br />&nbsp;&nbsp;} stack_node;<br /><br />/*&nbsp;The next 4 #defines implement a very fast in-line stack abstraction.*/<br />/*&nbsp;The stack needs log (total_elements) entries (we could even subtract<br />&nbsp;&nbsp; log(MAX_THRESH)).&nbsp;&nbsp;Since total_elements has type size_t, we get as<br />&nbsp;&nbsp; upper bound for log (total_elements):<br />&nbsp;&nbsp; bits per byte (CHAR_BIT) * sizeof(size_t).&nbsp;&nbsp;*/<br />#define STACK_SIZE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(CHAR_BIT&nbsp;*sizeof(size_t))<br />#define PUSH(low, high) ((void) ((top-&gt;lo = (low)), (top-&gt;hi = (high)), ++top))<br />#define POP(low, high)&nbsp;&nbsp;((void) (--top, (low = top-&gt;lo), (high = top-&gt;hi)))<br />#define STACK_NOT_EMPTY (stack &lt; top)<br /><br /><br />/*&nbsp;Order size using quicksort.&nbsp;&nbsp;This implementation incorporates<br />&nbsp;&nbsp; four optimizations discussed in Sedgewick:<br /><br />&nbsp;&nbsp; 1. Non-recursive, using an explicit stack of pointer that store the<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next array partition to sort.&nbsp;&nbsp;To save time, this maximum amount<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of space required to store an array of SIZE_MAX is allocated on the<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.&nbsp;&nbsp;Assuming a 32-bit (64 bit) integer for size_t, this needs<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;only 32 * sizeof(stack_node) == 256 bytes (for 64 bit: 1024 bytes).<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pretty cheap, actually.<br /><br />&nbsp;&nbsp; 2. Chose the pivot element using a median-of-three decision tree.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This reduces the probability of selecting a bad pivot value and<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eliminates certain extraneous comparisons.<br /><br />&nbsp;&nbsp; 3. Only quicksorts TOTAL_ELEMS / MAX_THRESH partitions, leaving<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;insertion sort to order the MAX_THRESH items within each partition.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is a big win, since insertion sort is faster for small, mostly<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sorted array segments.<br /><br />&nbsp;&nbsp; 4. The larger of the two sub-partitions is always pushed onto the<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack first, with the algorithm then concentrating on the<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;smaller partition.&nbsp;&nbsp;This *guarantees* no more than log (total_elems)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack size is needed (actually O(1) in this case)!&nbsp;&nbsp;*/<br /><br />void<br />_quicksort (void&nbsp;*const&nbsp;pbase, size_t&nbsp;total_elems, size_t&nbsp;size,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;__compar_d_fn_t cmp, void&nbsp;*arg)<br />{<br />&nbsp;&nbsp;register&nbsp;char&nbsp;*base_ptr = (char&nbsp;*) pbase;<br /><br />&nbsp;&nbsp;const&nbsp;size_t&nbsp;max_thresh = MAX_THRESH * size;<br /><br />&nbsp;&nbsp;if&nbsp;(total_elems == 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Avoid lossage with unsigned arithmetic below.&nbsp;&nbsp;*/<br />&nbsp;&nbsp;&nbsp;&nbsp;return;<br /><br />&nbsp;&nbsp;if&nbsp;(total_elems &gt; MAX_THRESH)<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*lo = base_ptr;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*hi = &amp;lo[size * (total_elems - 1)];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack_node stack[STACK_SIZE];<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack_node *top = stack;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PUSH (NULL, NULL);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(STACK_NOT_EMPTY)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*left_ptr;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*right_ptr;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Select median value from among LO, MID, and HI. Rearrange<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LO and HI so the three values are sorted. This lowers the<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; probability of picking a pathological pivot value and<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; skips a comparison for both the LEFT_PTR and RIGHT_PTR in<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the while loops.*/<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*mid = lo + size * ((hi - lo) / size &gt;&gt; 1);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((*cmp) ((void&nbsp;*) mid, (void&nbsp;*) lo, arg) &lt; 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SWAP (mid, lo, size);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((*cmp) ((void&nbsp;*) hi, (void&nbsp;*) mid, arg) &lt; 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SWAP (mid, hi, size);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;goto&nbsp;jump_over;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((*cmp) ((void&nbsp;*) mid, (void&nbsp;*) lo, arg) &lt; 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SWAP (mid, lo, size);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jump_over:;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left_ptr&nbsp;&nbsp;= lo + size;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right_ptr = hi - size;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Here's the famous ``collapse the walls'' section of quicksort.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gotta like those tight inner loops!&nbsp;&nbsp;They are the main reason<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; that this algorithm runs much faster than others.*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;do<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;((*cmp) ((void&nbsp;*) left_ptr, (void&nbsp;*) mid, arg) &lt; 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left_ptr += size;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;((*cmp) ((void&nbsp;*) mid, (void&nbsp;*) right_ptr, arg) &lt; 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right_ptr -= size;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(left_ptr &lt; right_ptr)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SWAP (left_ptr, right_ptr, size);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(mid == left_ptr)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid = right_ptr;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(mid == right_ptr)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mid = left_ptr;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left_ptr += size;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right_ptr -= size;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;(left_ptr == right_ptr)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left_ptr += size;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right_ptr -= size;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(left_ptr &lt;= right_ptr);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Set up pointers for next iteration.&nbsp;&nbsp;First determine whether<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; left and right partitions are below the threshold size.&nbsp;&nbsp;If so,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ignore one or both.&nbsp;&nbsp;Otherwise, push the larger partition's<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds on the stack and continue sorting the smaller one.*/<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((size_t) (right_ptr - lo) &lt;= max_thresh)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((size_t) (hi - left_ptr) &lt;= max_thresh)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Ignore both small partitions.*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;POP (lo, hi);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Ignore small left partition.*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lo = left_ptr;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;((size_t) (hi - left_ptr) &lt;= max_thresh)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Ignore small right partition.*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hi = right_ptr;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;((right_ptr - lo) &gt; (hi - left_ptr))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Push larger left partition indices.*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PUSH (lo, right_ptr);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lo = left_ptr;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Push larger right partition indices.*/<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PUSH (left_ptr, hi);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hi = right_ptr;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br /><br />&nbsp;&nbsp;/*&nbsp;Once the BASE_PTR array is partially sorted by quicksort the rest<br />&nbsp;&nbsp;&nbsp;&nbsp; is completely sorted using insertion sort, since this is efficient<br />&nbsp;&nbsp;&nbsp;&nbsp; for partitions below MAX_THRESH size. BASE_PTR points to the beginning<br />&nbsp;&nbsp;&nbsp;&nbsp; of the array to sort, and END_PTR points at the very last element in<br />&nbsp;&nbsp;&nbsp;&nbsp; the array (*not* one beyond it!).*/<br /><br />#define min(x, y) ((x) &lt; (y) ? (x) : (y))<br /><br />&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*const&nbsp;end_ptr = &amp;base_ptr[size * (total_elems - 1)];<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*tmp_ptr = base_ptr;<br />&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*thresh = min(end_ptr, base_ptr + max_thresh);<br />&nbsp;&nbsp;&nbsp;&nbsp;register&nbsp;char&nbsp;*run_ptr;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Find smallest element in first threshold and place it at the<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; array's beginning.&nbsp;&nbsp;This is the smallest array element,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and the operation speeds up insertion sort's inner loop.*/<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(run_ptr = tmp_ptr + size; run_ptr &lt;= thresh; run_ptr += size)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;((*cmp) ((void&nbsp;*) run_ptr, (void&nbsp;*) tmp_ptr, arg) &lt; 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp_ptr = run_ptr;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(tmp_ptr != base_ptr)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SWAP (tmp_ptr, base_ptr, size);<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Insertion sort, running from left-hand-side up to right-hand-side.&nbsp;&nbsp;*/<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;run_ptr = base_ptr + size;<br />&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;((run_ptr += size) &lt;= end_ptr)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp_ptr = run_ptr - size;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;((*cmp) ((void&nbsp;*) run_ptr, (void&nbsp;*) tmp_ptr, arg) &lt; 0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp_ptr -= size;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmp_ptr += size;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(tmp_ptr != run_ptr)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*trav;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;trav = run_ptr + size;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(--trav &gt;= run_ptr)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;c = *trav;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*hi, *lo;<br /><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(hi = lo = trav; (lo -= size) &gt;= tmp_ptr; hi = lo)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*hi = *lo;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*hi = c;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;}<br />}<br /></p><img src="http://hiphotos.baidu.com/pengjunlong/pic/item/51b68716bfb53105f2de3235.jpg" height="5" width="77" /> <img src="http://hiphotos.baidu.com/pengjunlong/pic/item/6257b551b7912adb8d543035.jpg" /> <img src="http://hiphotos.baidu.com/pengjunlong/pic/item/6c73ae8fca1b0abaf11f3635.jpg" /> </div>
---
layout: post
title: Berkeley套接字
time: 2011-07-30 17:12
tags: 好好学习天天向上
---

<div id=content class="content mod-cs-content text-content clearfix"> Berkeley套接字接口<p><b>Berkeley套接字接口</b>，一个应用程序接口（API），使用一个Internet套接字的概念，使主机间或者一台计算机上的进程间可以通讯。 它可以在很多不同的输入/输出设备和驱动之上运行，尽管这有赖于操作系统的具体实现。 接口实现用于TCP/IP协议，因此它是维持Internet的基本技术之一。 它是由加利福尼亚的伯克利大学开发，最初用于Unix系统。 如今，所有的现代操作系统都有一些源于Berkeley套接字接口的实现，它已成为连接Internet的标准接口。</p><p>套接字接口的接入有三个不同的级别，最基础的也是最有效的就是raw socket级别接入。 很少的应用程序需要在外向通讯控制的这个级别接入，所以raw socket级别是只为了用于开发计算机Internet相关技术的。 最近几年，大多数的操作系统已经实现了对它的全方位支持，包括Windows XP。</p>[<a href="http://zh.wikipedia.org/w/index.php?title=Berkeley%E5%A5%97%E6%8E%A5%E5%AD%97&amp;action=edit&amp;section=2" title="编辑段落  头文件  ">编辑</a>]头文件<p>Berkeley套接字接口的定义在几个头文件中。 这些文件的名字和内容与具体的实现之间有些许的不同。 大体上包括：</p><dl><dd><dl><dt><strong><code>&lt;sys/socket.h&gt;</code></strong></dt><dd>核心BSD套接字函数和数据结构。</dd><dd>AF_INET、AF_INET6 地址集和它们相应的协议集PF_INET、PF_INET6. 广泛用于Internet，这些包括了IP地址和TCP、UDP端口号。</dd><dt><code>&lt;netinet/in.h&gt;</code></dt><dt><code>&lt;sys/un.h&gt;</code></dt><dd>PF_UNIX/PF_LOCAL 地址集。 用于同一计算机上程序间的通讯。 不用于网络通讯。</dd><dt><code>&lt;arpa/inet.h&gt;</code></dt><dd>处理数值型IP地址的函数。</dd><dt><code>&lt;netdb.h&gt;</code></dt><dd>将协议名和主机名翻译为数值地址的函数。 搜索本地数据以及DNS。</dd></dl></dd></dl>[<a href="http://zh.wikipedia.org/w/index.php?title=Berkeley%E5%A5%97%E6%8E%A5%E5%AD%97&amp;action=edit&amp;section=3" title="编辑段落  套接字API函数  ">编辑</a>]套接字API函数<p>这个列表是一个Berkeley套接字API库提供的函数或者方法的概要：</p><ul><li><code>socket()</code>&nbsp;创建一个新的确定类型的套接字，类型用一个整型数值标识，并为它分配系统资源。</li><li><code>bind()</code>&nbsp;一般用于服务器端，将一个套接字与一个套接字地址结构相关联，比如，一个指定的本地端口和IP地址。</li><li><code>listen()</code>&nbsp;用于服务器端，使一个绑定的TCP套接字进入监听状态。</li><li><code>connect()</code>&nbsp;用于客户端，为一个套接字分配一个自由的本地端口号。 如果是TCP套接字的话，它会试图获得一个新的TCP连接。</li><li><code>accept()</code>&nbsp;用于服务器端。 它接受一个从远端客户端发出的创建一个新的TCP连接的接入请求，创建一个新的套接字，与该连接相应的套接字地址相关联。</li><li><code>send()</code>和<code>recv()</code>,或者<code>write()</code>和<code>read()</code>,或者<code>recvfrom()</code>和<code>sendto()</code>, 用于往/从远程套接字发送和接受数据。</li><li><code>close()</code>&nbsp;用于系统释放分配给一个套接字的资源。 如果是TCP，连接会被中断。</li><li><code>gethostbyname()</code>和<code>gethostbyaddr()</code>&nbsp;用于解析主机名和地址。</li><li><code>select()</code>&nbsp;用于修整有如下情况的套接字列表： 准备读，准备写或者是有错误。</li><li><code>poll()</code>&nbsp;用于检查套接字的状态。 套接字可以被测试，看是否可以写入、读取或是有错误。</li><li><code>getsockopt()</code>&nbsp;用于查询指定的套接字一个特定的套接字选项的当前值。</li><li><code>setsockopt()</code>&nbsp;用于为指定的套接字设定一个特定的套接字选项。</li></ul><p>更多的细节如下给出。</p>[<a href="http://zh.wikipedia.org/w/index.php?title=Berkeley%E5%A5%97%E6%8E%A5%E5%AD%97&amp;action=edit&amp;section=4" title="编辑段落  socket()  ">编辑</a>]socket()<p><code>socket()</code>&nbsp;为通讯创建一个端点，为套接字返回一个文件描述符。 socket() 有三个参数：</p><ul><li><var>domain</var>&nbsp;为创建的套接字指定协议集。 例如：<ul><li><code>PF_INET</code>&nbsp;表示IPv4网络协议</li><li><code>PF_INET6</code>&nbsp;表示IPv6</li><li><code>PF_UNIX</code>&nbsp;表示本地套接字（使用一个文件）</li></ul></li><li><var>type</var>&nbsp;如下：<ul><li><code>SOCK_STREAM</code>&nbsp;（可靠的面向流服务或流套接字）</li><li><code>SOCK_DGRAM</code>&nbsp;（数据报文服务或者数据报文套接字）</li><li><code>SOCK_SEQPACKET</code>&nbsp;（可靠的连续数据包服务）</li><li><code>SOCK_RAW</code>&nbsp;(在网络层之上的原始协议)。</li></ul></li><li><var>protocol</var>&nbsp;指定实际使用的传输协议。 最常见的就是<code><a href="http://zh.wikipedia.org/wiki/Transmission_Control_Protocol" title="Transmission Control Protocol">IPPROTO_TCP</a></code>、<code><a href="http://zh.wikipedia.org/wiki/SCTP" title="SCTP">IPPROTO_SCTP</a></code>、<code><a href="http://zh.wikipedia.org/wiki/User_Datagram_Protocol" title="User Datagram Protocol">IPPROTO_UDP</a></code>、<code><a href="http://zh.wikipedia.org/wiki/DCCP" title="DCCP">IPPROTO_DCCP</a></code>。这些协议都在&lt;netinet/in.h&gt;中有详细说明。 如果该项为“<code>0</code>”的话，即根据选定的domain和type选择使用缺省协议。</li></ul><p>如果发生错误，函数返回值为-1。 否则，函数会返回一个代表新分配的描述符的整数。</p><dl><dt>原型：</dt></dl>int socket(int domain, int type, int protocol)。[<a href="http://zh.wikipedia.org/w/index.php?title=Berkeley%E5%A5%97%E6%8E%A5%E5%AD%97&amp;action=edit&amp;section=5" title="编辑段落  bind()  ">编辑</a>]bind()<p><code>bind()</code>&nbsp;为一个套接字分配地址。当使用<code>socket()</code>创建套接字后，只赋予其所使用的协议，并未分配地址。在接受其它主机的连接前，必须先调用bind()为套接字分配一个地址。<code>bind()</code>有三个参数：</p><ul><li><code>sockfd</code>, 表示使用bind函数的套接字描述符</li><li><code>my_addr</code>, 指向sockaddr结构（用于表示所分配地址）的指针</li><li><code>addrlen</code>, 用socklen_t字段指定了sockaddr结构的长度</li></ul><p>如果发生错误，函数返回值为-1，否则为0。</p><dl><dt>原型</dt></dl>int bind(int sockfd, const struct sockaddr *my_addr, socklen_t addrlen);[<a href="http://zh.wikipedia.org/w/index.php?title=Berkeley%E5%A5%97%E6%8E%A5%E5%AD%97&amp;action=edit&amp;section=6" title="编辑段落  listen()  ">编辑</a>]listen()<p>当socket和一个地址绑定之后，<code>listen()</code>函数会开始监听可能的连接请求。然而，这只能在有可靠数据流保证的时候使用，例如：数据类型(<code>SOCK_STREAM</code>,&nbsp;<code>SOCK_SEQPACKET</code>)。</p><p>listen()函数需要两个参数：</p><ul><li><code>sockfd</code>, 一个socket的描述符.</li><li><code>backlog</code>, 一个决定监听队列大小的整数，当有一个连接请求到来，就会进入此监听队列，当队列满后，新的连接请求会返回错误。当请求被接受，返回 0。反之，错误返回 -1。</li></ul><p><b>原型</b>:</p>int listen(int sockfd, int backlog);<p></p> </div>
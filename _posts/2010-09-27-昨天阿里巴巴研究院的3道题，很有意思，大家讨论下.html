tag=好好学习天天向上
<div id=content class="content mod-cs-content text-content clearfix"> 1. 有无序的实数列V[N]，要求求里面大小相邻的实数的差的最大值，关键是要求线性空间和线性时间<br /><br />2. 25匹赛马，5个跑道，也就是说每次有5匹马可以同时比赛。问最少比赛多少次可以知道跑得最快的5匹马<br /><br />3.  有一个函数int  getNum()，每运行一次可以从一个数组V[N]里面取出一个数，N未知，当数取完的时候，函数返回NULL。现在要求写一个函数int  get()，这个函数运行一次可以从V[N]里随机取出一个数，而这个数必须是符合1/N平均分布的，也就是说V[N]里面任意一个数都有1/N的机会被 取出，要求空间复杂度为O（1）<br /><br /><br /><br /><br /><br />第一题：<br />1.扫描一遍数组，找出最大和最小的数，分别记为max和min,设数组总数为N，则两个相邻数之间最大距离至少为diff=(max-min)/N<br />2.定义一个数组unsigned int nums[N]，假设原数组为reals[N],则新数组nums[i]=(reals[i]-min)/diff<br />3.建一个N维长度的hash散列，并用链表解决冲突问题，在hash表中记录下数的下标信息，具体参见下面代码。<br />4.依次扫描hash 散列，求出相邻最大距离。<br />代码如下：<br /><br />#include &quot;stdafx.h&quot;<br />#include &quot;stdlib.h&quot;<br />#define MAX_LENGTH 1000<br />struct Num<br />{<br />double real;<br />struct Num *next;<br />};<br />int main()<br />{<br />int a;<br />double reals[MAX_LENGTH];<br />int N=0;<br />for(N=0;N&lt;MAX_LENGTH;N++)<br />{<br />float temp;<br />printf(&quot;请输入第%d个数，-10000表示结束\n&quot;,N+1);<br /><br />scanf(&quot;%f&quot;,&amp;temp);<br />if(temp==-10000.0)<br />break;<br />//printf(&quot;%f\n&quot;,temp);<br />reals[N]=temp;<br />}<br /><br />int i,j;<br /><br />//获取最大数和最小数<br />double min,max,diff;<br />min=max=reals[0];<br />for(i=1;i&lt;N;i++)<br />{<br />if(reals[i]&lt;min)<br />min=reals[i];<br />if(reals[i]&gt;max)<br />max=reals[i];<br />}<br /><br />//计算平均间隔<br />diff=(max-min)/(N-1);<br />//printf(&quot;max=%f,min=%f,diff=%f,N=%d\n&quot;,max,min,diff,N);<br />//scanf(&quot;%d&quot;,min);<br /><br />//将原实数数组reals映射到一个整型数组<br />int *nums=new int[N];<br />for(i=0;i&lt;N;i++)<br />{<br />nums[i]=(reals[i]-min)/diff;<br />//printf(&quot;%d\n&quot;,nums[i]);<br />}<br /><br />//建立一个N维的hash表，表中每个元素为一指针<br />struct Num **hashN=(struct Num **)malloc(N*sizeof(struct Num *));<br />for(i=0;i&lt;N;i++)<br />hashN[i]=NULL;<br /><br />//将数组Nums映射到hashN<br />struct Num *temp;<br />for(i=0;i&lt;N;i++)<br />{<br />temp=(struct Num*)malloc(sizeof(struct Num));<br />temp-&gt;real=reals[i];<br />temp-&gt;next=NULL;<br />if(hashN[nums[i]]==NULL)<br />{<br />hashN[nums[i]]=temp;<br />}<br />else<br />{<br />//将reals[i]插入hash散列中，若有冲突，按从小到大的顺序插入<br />struct Num *p=hashN[nums[i]];<br />if(p-&gt;real&lt;temp-&gt;real)<br />{<br />temp-&gt;next=p;<br />hashN[nums[i]]=temp;<br />}<br />else<br />{<br />while(p-&gt;next!=NULL&amp;&amp;p-&gt;next-&gt;real&gt;temp-&gt;real)p=p-&gt;next;<br />temp-&gt;next=p-&gt;next;<br />p-&gt;next=temp;<br />}  <br />}<br />}<br /><br />//计算相邻最大距离<br />double maxdiff=0;<br />double pre=0,cur=0;//用来保存hashN列中两个相邻的数<br />double left=0,right=0;//用来保存最大两个相邻的数<br />struct Num *pcur;<br />pre=hashN[0]-&gt;real;<br />i=0;<br />while(i&lt;N)<br />{<br />if(hashN[i]==NULL)<br />{<br />i++;<br />}<br />else<br />{<br />pcur=hashN[i];<br />while(pcur-&gt;next!=NULL)pcur=pcur-&gt;next;<br />cur=pcur-&gt;real;<br />if(cur-pre&gt;maxdiff)<br />{<br />//printf(&quot;max,i=%d\n&quot;,i);<br />maxdiff=cur-pre;<br />left=pre;<br />right=cur;<br />}<br />pre=hashN[i]-&gt;real; <br />i++;<br />}<br />}<br />printf(&quot;最大相邻数差为：%f,两个相邻数分别为:%f,%f\n&quot;,maxdiff,left,right);<br />return 0;<br />}&#160; <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />马的问题，任何情况一种9次必然能比出来的方法<br />前5次大家都一样，排序后如下<br />A1,A2,A3,A4,A5<br />B1,B2,B3,B4,B5<br />C1,C2,C3,C4,C5<br />D1,D2,D3,D4,D5<br />E1,E2,E3,E4,E5<br />第六次，最大值比较，找出最快的马<br />A1<br />B1<br />C1<br />D1<br />E1<br />第七次比较，找出第二和第三，这一步是关键，请仔细观察，我们假设A1最快（B1，C1，D1，E1也没问题）<br />A2,A3<br />B1,B2<br />C1<br />以上这5匹马中有2只必然是第二快和第三快， 为什么大家自己去研究<br /><br />第八次比较，要根据第七次的结果，如果第七次是A2,A3， 第八次可以得到第四快和第五快的马，做法和第七次相同，如果不是A2,A3，第八次只能得到跑第四快的马<br /><br />第九次必然可以得到第五名<br /><br /><br />第七次比较是关键<br /><br />想法和49楼的类似，但只需8次就可以啦<br />前6次和49楼一样，并假设第6次的比赛结果顺序为A1、B1、C1、D1、E1<br />第7次参加比赛的马匹为<br />A2 A3 B2&#160; C2&#160; D1<br /><br />下面就3种第7次可能的比赛结果进行分析：<br />1、若第7次的比赛可能的一种结果为：<br />A2 A3 B2 C2 D1<br />此时必进入前5的是A1、A2、A3<br />可能进前5的是A4、A5、B1、B2、C1<br />则第8次为<br />A4、A5、B1、B2、C1<br />取前2名，与A1、A2、A3一直即为前5<br />2、若第7比赛结果为B2、A2、C2、A3、D1<br />此时必进入前5的是A1、B1、B2<br />可能进入前5的是A2、B3、B4、C1<br />第8次只要让这4匹马参赛就可以啦<br />3、若第7次比赛结果为D1、C2、A2、A3、B1<br />此时必进入前5的是A1、B1、C1、D1<br />而剩下的第5匹马只可能出现在C2、D2、E1这3匹马中，自然，让这3匹马参加第8次比赛就可以啦<br />总之，不管第7次的比赛结果如何，都在第8次比赛中做出适当的安排，即而可以在8次比赛后确定跑得最快的前5匹马。<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />第三问:<br /><dl><dt>C/C++ code</dt><dd> int GetRand() { int i=1; int nRet = 0; int nVal = 0; while((nRet=getNum())!=NULL) {     if(rand()%(i++)==0) nVal = nRet; } return nVal; } </dd></dl> </div>
tag=好好学习天天向上
<div id=content class="content mod-cs-content text-content clearfix"> <p>某存储系统中，假设有N个容量为G的存储单元。用户不断向该存储系统上传数据，假设用户数据的size是一个随机数。现在需要设计一个负载均衡系统，要求能够合理分配用户上传请求到不同的存储单元，从而保证每个存储单元的写负载以及空间使用都比较接近，需要考虑如下：<br /><br />1.初始化时，N个存储单元剩余空间相同<br />2.初始化时，N个存储单元剩余空间相差很大<br /><br />根据以上描述设计实现该应用场景的程序代码，要求模块化实现时，清晰地表示存储单元间的剩余空间以及写负载情况...</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>存储负载均衡</p><p><br /></p>这个题目从纯技术的角度来看难度应该不大，但需要考虑的东西比较多，个人感觉这是考一个人的技术经验的题目。<br /><br />可以考虑建立一个这样的储存单元结构<br /><dl><dt>C/C++ code</dt><dd>struct Storage{    unsigned int SIZE;                // 储存单元容量    unsigned int PCT_USED;            // 已用容量百分比，比如已经用了90%，那么PCT_USED=90    void addData(unsigned int size)    // 新增数据时，修改PCT_USED    {        unsigned int used = SIZE * PCT_USED /100 + size;        PCT_USED = used / SIZE * 100;    }    void deleteData(unsigned int size)    // 删除数据时，修改PCT_USED    {        unsigned int used = SIZE * PCT_USED /100 - size;        PCT_USED = used / SIZE * 100;    }};</dd></dl><br /><br />下面就定义一个管理类(同时也是容器)，用来管理这些Storage。 比如叫StorageMan<br /><dl><dt>C/C++ code</dt><dd>class StorageMan{private：     Storage st[N];          // 假定有N个Storage，此处当然可以用动态内存分配public：     Storage getStorage()     {          // 在N个Storage中找到PCT_USED最低的Storage对象，并返回。          // 如果有多个Storage的PCT_USED相同，则返回SIZE最大的那个Storage          // 具体可以用快排进行排序     }}；</dd></dl><br /><br />从StorageMan得到了可用的Storage对象，那么就可以用Storage来操作数据(增加或者删除)，同时更新StorageMan中该对象的PCT_USED。<br /><br />最后提醒一下，Storage最好做成一个Singleton，具体这方面的做法，可以参考：<br /><a href="http://blog.csdn.net/pathuang68/archive/2009/12/09/4974821.aspx" title="C++实现Singleton模式" target="_blank">C++实现Singleton模式</a><br />这样可以防止资源竞争。<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> </div>
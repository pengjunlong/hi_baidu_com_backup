<h2>好好学习天天向上</h2><br/><h1>shell脚本中的一些特殊符号--web数据收集方法</h1><hr/>
<div id=content class="content mod-cs-content text-content clearfix"> <p>1、{} 大括号：<br />用法一：通配符扩展 </p><p>代码:<br />ls my_{finger,toe}s</p><p>这条命令相当于如下命令的组合：</p><p>代码: </p><blockquote><p>ls my_fingers my_toes<br />mkdir {userA,userB,userC}-{home,bin,data}</p></blockquote><p>我们将得到 userA-home, userA-bin, userA-data, userB-home, userB-bin,userB-data,userC-home, userC-bin, userC-data，这几个目录<br />用法二：可用于语句块的构造，语句之间用回车隔开。如果你想在某些使用单个语句的地方（比如在AND或OR列表中）使用多条语句，你可以把它们括在花括号{}中来构造一个语句块。</p><p>代码:</p><blockquote><p>grep -v “$cdcatnum” $strack_file &gt; $temp_file<br />cat $temp_file &gt; $strack_file<br />echo<br />cat -n file1</p></blockquote><p>(注：以上大括号中的四句命令够成了一个语句块)<br />用法三：参数扩展</p><p>代码:<br />${name:-default} 使用一个默认值（一般是空值）来代替那些空的或者没有赋值的变量name；<br />${name:=default}使用指定值来代替空的或者没有赋值的变量name；<br />${name:?message}如果变量为空或者未赋值，那么就会显示出错误信息并中止脚本的执行同时返回退出码1。<br />${#name} 给出name的长度<br />${name%word} 从name的尾部开始删除与word匹配的最小部分，然后返回剩余部分<br />${name%%word} 从name的尾部开始删除与word匹配的最长部分，然后返回剩余部分<br />${name#word} 从name的头部开始删除与word匹配的最小部分，然后返回剩余部分<br />${name##word} 从name的头部开始删除与word匹配的最长部分，然后返回剩余部分</p><p>（注，name为变量名，word为要匹配的字符串）<br />用法三在处理字符串和未知变量时，是很有用的。</p><p>2、[] 中括号：<br />用法一：通配符扩展：<br />允许匹配方括号中任何一个单个字符</p><p>代码:<br />ls /[eh][to][cm]*</p><p>相当于执行 ls /etc /home（若有/eom目录，就相当于会执行ls /etc /home /eom）<br />注：在mkdir命令下不能扩展<br />用法二：用于条件判断符号：<br />[]符号可理解为指向test命令的一个软链接，所以其用法可完全参照test，将test位置替换为[便可。</p><p>代码:<br />if [ &quot;$?&quot; != 0 ] 等价于 if test “$?” != 0<br />then echo “Executes error”</p><p>3、`command` 反引号：<br />`command`与$(command)的含义相同，都是返回当前执行命令的结果 </p><p>代码: </p><blockquote><p>#!/bin/sh<br />for file in $(ls f*.sh);do<br />    lpr $file<br />done<br />exit 0</p></blockquote><p>该例实现了扩展f*.sh给出所有匹配模式的文件的名字。</p><p>4、’string’ 单引号 和 “string” 双引号<br />双引号：如果想在定义的变量中加入空格，就必须使用单引号或双引号，<br />单、双引号的区别在于双引号转义特殊字符而单引号不转义特殊字符</p><blockquote><p>$ heyyou=home<br />$ echo ‘$heyyou’<br />$ $heyyou （$没有转义）<br />eg: $ heyyou=home<br />$ echo “$heyyou”<br />$ home （很明显，$转义了输出了heyyou变量的值）</p></blockquote><p>5、$# 它的作用是告诉你引用变量的总数量是多少； </p><p>代码:<br />$$ 它的作用是告诉你shell脚本的进程号；<br />$* 以一个单字符串显示所有的脚本传递的参数。等价于$1 $2 $3…….；<br />$@ 与$*基本类似（参见序号7），但在数组赋值时有些不同；<br />$? 前一个命令的退出码；<br />$- 显示shell使用的当前选项；<br />$! 最后一个后台运行的进程ID号。</p><p>6、$((…))语法：对括号内的表达式求值 </p><p>代码: </p><blockquote><p>#!/bin/sh<br />x=0<br />hile [ &quot;$x&quot; -ne 10 ];do<br />echo $x<br />x=$(($x+1))<br />done<br />exit 0</p></blockquote><p>7、shell中几种特殊的参数变量的引用 </p><p>代码:<br />$1、$2、$3……${10}、${11}、${12}…… ：表示脚本传入的的各个参数，注意当需表示两位数以后的参数时数字要用花括号括起。<br />$@ 列出所有的参数，各参数用空格隔开<br />$*: 列出所有的参数，各参数用环境变量IFS的第一个字符隔开</p><p>8、命令列表：<br />AND列表 statement1 &amp;&amp; statement2 &amp;&amp; statement3 &amp;&amp; …:只有在前面所有的命令都执行成功的情况下才执行后一条命令<br />OR列表 statement1 || statement2 || statement3 || …:允许执行一系列命令直到有一条命令成功为止，其后所有命令将不再被执行<br />#!/bin/sh</p><p>代码: </p><blockquote><p>touch file_one<br />rm -f file_two<br />if [ -f file_one ] &amp;&amp; echo “hello” &amp;&amp; [ -f file_two ] &amp;&amp; echo ” there”<br />then<br />echo “in if”<br />else<br />echo “in else”<br />fi<br />exit 0</p></blockquote><p>上例的输出为：</p><p>代码:<br />hello<br />in else</p><p>关于AND列表与OR列表，在逻辑判断中很使用，下面就举一个其最常用的例子：</p><p>代码:<br />[ condition ] &amp;&amp; command for true || command for false:</p><p>当条件为真时，执行commandfor true ,当条件为假时，执行command for false</p><p>9、: 冒号：内建空指令，返回值为0 </p><p>代码:<br />$ :<br />$ echo $?<br />$ 0<br />while: (该语句结构可实现一个无限循环)</p><p>10、; 分号: 在 shell 中，担任”连续指令”功能的符号就是”分号” </p><p>代码:<br />cd ~/backup ; mkdir startup ; cp ~/.* startup/.</p><p>11、# 井号：表示符号后面的是注解文字，不会被执行； </p><p>代码:<br />* 匹配文件名中的任何字符，包括字符串；<br />？ 匹配文件名中的任何单个字符。<br />~ 代表使用者的 home 目录</p><p>12、\ 倒斜线：<br />放在指令前，有取消 aliases（别名） 的作用；<br />放在特殊符号前，则该特殊符号的作用消失；<br />放在指令的最末端，表示指令连接下一行（使得回车符无效，只起换行作用）</p><p>13、! 感叹号：<br />通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表”不等于” </p><p>14、** 次方运算：两个星号在运算时代表 “次方” 的意思 </p><p>代码: </p><blockquote><p>let “sus=2**3″<br />echo “sus = $sus”<br />$ sus = 8 </p><p>&nbsp;</p><p>进行web分析，首要也是非常重要的一步就是有效的收集web数据，当用户和web站点进行交互时，通常有四种方法可以用来收集数据：web日志文件、web beacons、Javascript标记以及包嗅探器，本文将对这种方法进行详细描述。&nbsp;</p><p><strong>一. 捕获点击流数据的方法</strong></p><p>1)&nbsp;&nbsp;Web日志——应当用于搜索引擎日志分析</p><p>捕获过程：</p><ul><li>客户在浏览器上输入url</li><li>页面的请求到达web服务器</li><li>web服务器接受请求，在web日志中为这个请求创建一个条目（通常捕获的数据包括页面的名称、IP地址、客户的浏览器以及日期时间戳等）</li><li>web服务器将页面发送给客户</li></ul><p>优点：web日志可能是最容易被访问的数据源；可以捕获和存储搜索引擎机器人对于站点的访问和行为的唯一的数据捕获机制；使用web日志，总是可以拥有数据。</p><p>注意点：web日志主要是为了捕获技术信息（404错误、服务器使用趋势、浏览器类型等）而创建的，如果用于捕获商务和市场信息并不理想；如果web服务器没有设置cookie，对访客进行某种程度的准确识别将是比较困难的；ISP和代理服务器缓存的页面意味着一些流量对web服务器来说是不可见的，因此日志文件里就没有那个请求的条目。</p><p>2)&nbsp;&nbsp;Web beacons——用于追踪客户行为和电子邮件的打开和查看机率</p><p>Web beacons通常是web页面中1*1像素的透明图像，位于一个img src的html标记之内。这个透明图像通常存放在一个第三方的服务器上，与存放web页面的服务器不同。</p><p>捕获过程：</p><ul><li>客户在浏览器上输入url</li><li>页面的请求到达一个web服务器</li><li>web服务器将页面返回，连同一个对第三方服务器上的1*1像素的图像的获取请求</li><li>页面被加载，执行对该1*1像素的图像的调用，发送页面视图的数据给第三方服务器</li><li>第三方服务器将图像返回浏览器，一起返回的还包括可以读cookie和捕获匿名访客数据，这些数据包括已经浏览的页面、IP地址、页面浏览的时间、之前设置的cookie和更多的内容</li></ul><p>Web beacons也可以用于电子邮件，和web页面一样，当邮件被下载到邮件阅读器则请求透明图像，邮件是否被阅读的数据就被返回和记录。</p><p>优点：web beacons易于实现；由于机器人并不执行图像请求，所以web beacons不会收集到无用于数据，这样可以使得日志可以维持在一个可管理的规模上，不需要复杂的过滤</p><p>注意点：</p><ul><li>beacons常常和广告以及广告网联系在一起，因此可能受到一些指责；跨越多个站点追踪一个访客的行为，其中很多隐私问题会被披露，因此很多访客使用全局的选项配置，或者使用工具软件自动删除cookie，这些都削弱了web beacons的数据收集能力</li><li>如果在邮件程序中关闭了图像请求，web beacons也无法收集邮件信息了</li><li>beacons不能像javascrip标记那样，可以对要捕获的数据进行扩展和定制，它捕获的数据少，但可以跨越很大范围的站点</li><li>根据其特性，beacons和第三方的服务器进行交互，主要是设置第三方的cookie，有些浏览器不接受或者不显示第三方的cookie，工具软件也可能会删除第三方的cookie，这都使得beacons难以追踪用户的访问</li></ul><p>3)&nbsp;Javascript标记——最流行的捕捉方式</p><p>捕获过程：</p><ul><li>客户在浏览器中输入url</li><li>页面的请求到达一个web服务器</li><li>Web服务器将页面返回，连同附加在这一页面上的javascrip的代码片段</li><li>页面被加载，执行javascript的代码，收集信息，包括浏览的页面、关于访问者会话的细节、cookie，然后返回给数据收集服务器</li><li>有些情况下，当收到第一批数据的时候，服务器就将其余的代码返回给浏览器来设置cookie或者获取更多的数据</li></ul><p>好处：如果不能访问web服务器和web服务器日志，javscrip标记是唯一的选择，通过这种方式可以轻松的在页面中安装这些标记，或者使用ASP供应商来生成报表；不用担心页面缓存的问题，只要javscript标记可以执行，分析工具就可以收集数据；收集数据更灵活，还可以在一些特定的页面上实现定制的标记；javascript使得数据服务和数据捕获相分离；如果使用第三方的cookie，跨越多个域来跟踪用户变得更容易。</p><p>注意点：</p><ul><li>不是所有的用户都会开启javascript，目前还是有极少数的用户关闭了javascript</li><li>在页面上创建标记以收集数据，是一个艰苦的过程，需要在站点演化的过程中进行定期的维护</li><li>javascript标记收集的是“浏览器端”的数据，而不是“服务器端”的，一些站点并不是在cookie或url参数中存储数据，而是在访客会话期间，将数据存储在服务器上，这种情况下，标记是不能获取到相应的数据的</li><li>用javascript标记捕获关于下载和重定向的数据要比web日志更困难</li><li>如果站点的javascript已经负荷很重，站点上已经有大量的javascript在完成一系列智能化工作，慎用javascript标记来收集数据，有些情况下，可能造成冲突，甚至使网站无法正常工作</li></ul><p>4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 包嗅探器——专业性更强，但是也更复杂；如果javascript能够满足，暂时不考虑包嗅探器</p><p>捕获过程：</p><ul><li>客户在浏览器中输入url</li><li>请求被路由到web服务器。但在请求到达之前，它会通过一个基于软件或硬件的包嗅探器，收集请求的一些属性，将关于访问的更多数据返回给包嗅探器</li><li>包嗅探器将请求发送给web服务器</li><li>请求先传送给包嗅探器，然后返回给客户。包嗅探器捕获返回的页面信息并存储数据。一些包嗅探器方案的厂家还附加了javascript标记，从而可以回送给包嗅探器更多关于访问者的数据</li><li>包嗅探器将页面发送给用户浏览器</li></ul><p>好处：既可以收集到服务器端信息可以收集到用户端信息，可以即刻收集大量信息，要比用标准的javascript标记快得多</p><p>注意点：对于大多数公司来说，很难说服IT部门在web服务器端加一个额外的软件层或者物理硬件，对于这种非标准的做法，可能会遭到反对；包嗅控器收集Internet web服务器流量的原始包，面临着两个挑战：一个是需要将需要数据从原始数据中解析出来，另一个是隐私问题，原始数据中包括了用户的隐私数据；使用包嗅探器方法的同时，还需要使用javascript标记的方法，否则数据收集不全面。</p><p><strong>二.&nbsp;数据捕获机制需注意的事项</strong></p><p>1）&nbsp; 第一方vs第三方cookie</p><p>大部分的供应商会设置自己的（第三方）cookie，但你如果是自己进行数据捕获的话，尽量使用所在域的第一方cookie，这样至少可以越过安全设置和安全工具软件。</p><p>2）&nbsp; 数据所有权</p><p>主要是针对使用供应商捕获数据的情况，供应商输出数据，是聚合过的数据，如果想深入下去，就没有办法了，最好是能掌握所有数据的所有权</p><p>3）&nbsp; 用户用在最后一个页面上的时间难以计算</p><p>4）&nbsp; 所有的数据捕获机制都是脆弱和不完善的</p><p>5）&nbsp; 客户至上，确保客户能够获取页面而并非收集数据，高度警惕客户的隐私问题</p><p>6）&nbsp; 成本</p><p>参考资料：</p><p>精通web analytics</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p></blockquote> </div>
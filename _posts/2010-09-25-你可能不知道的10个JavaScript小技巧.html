tag=好好学习天天向上
<div id=content class="content mod-cs-content text-content clearfix"> 1.变量转换<br />看起来很简单，但据我所看到的，使用构造函数，像Array()或者Number()来进行变量转换是常用的做法。始终使用原始数据类型（有时也称为字面量）来转换变量，这种没有任何额外的影响的做法反而效率更高。<br /><br />view sourceprint?<br />1 var myVar   = &quot;3.14159&quot;, &#160; <br /><br />2 str     = &quot;&quot;+ myVar,//  to string &#160; <br /><br />3 int     = ~~myVar,  //  to integer &#160; <br /><br />4 float   = 1*myVar,  //  to float &#160; <br /><br />5 bool    = !!myVar,  /*  to boolean - any string with length &#160; <br /><br />6 and any number except 0 are true */&#160; <br /><br />7 array   = [myVar];  //  to array&#160; <br />转换日期(new Date(myVar))和正则表达式(new RegExp(myVar))必须使用构造函数，而且创建正则表达式的时候要使用/pattern/flags的形式。<br /><br /><br />2.十进制转换为十六进制或者八进制，或者反过来<br />你是不是写个单独的函数来转换十六进制（或者八进制）呢？马上停下吧！有更容易的现成的函数可以用：<br /><br />view sourceprint?<br />1 (int).toString(16); // converts int to hex, eg 12 =&gt; &quot;C&quot; &#160; <br /><br />2 (int).toString(8);  // converts int to octal, eg. 12 =&gt; &quot;14&quot; &#160; <br /><br />3 parseInt(string,16) // converts hex to int, eg. &quot;FF&quot; =&gt; 255 &#160; <br /><br />4 parseInt(string,8) // converts octal to int, eg. &quot;20&quot; =&gt; 16&#160; <br />3.玩转数字<br />除了上一节介绍的之外，这里有更多的处理数字的技巧<br /><br />view sourceprint?<br />1 0xFF; // Hex declaration, returns 255 &#160; <br /><br />2 020; // Octal declaration, returns 16 &#160; <br /><br />3 1e3; // Exponential, same as 1 * Math.pow(10,3), returns 1000 &#160; <br /><br />4 (1000).toExponential(); // Opposite with previous, returns 1e3 &#160; <br /><br />5 (3.1415).toFixed(3); // Rounding the number, returns &quot;3.142&quot;&#160; <br />4.Javascript版本检测<br />你 知道你的浏览器支持哪一个版本的Javascript吗？如果不知道的话，去维基百科查一下Javascript版本表吧。出于某种原 因，Javascript  1.7版本的某些特性是没有得到广泛的支持。不过大部分浏览器都支持了1.8版和1.8.1版的特性。（注：所有的IE浏览器（IE8或者更老的版本）只 支持1.5版的Javascript）这里有一个脚本，既能通过检测特征来检测JavaScript版本，它还能检查特定的Javascript版本所支 持的特性。<br /><br />view sourceprint?<br />01 var JS_ver  = []; &#160; <br /><br />02 (Number.prototype.toFixed)?JS_ver.push(&quot;1.5&quot;):false; &#160; <br /><br />03 ([].indexOf &amp;&amp; [].forEach)?JS_ver.push(&quot;1.6&quot;):false; &#160; <br /><br />04 ((function(){try {[a,b] = [0,1];return true;}catch(ex) {return false;}})())?JS_ver.push(&quot;1.7&quot;):false; &#160; <br /><br />05 ([].reduce &amp;&amp; [].reduceRight &amp;&amp; JSON)?JS_ver.push(&quot;1.8&quot;):false; &#160; <br /><br />06 (&quot;&quot;.trimLeft)?JS_ver.push(&quot;1.8.1&quot;):false; &#160; <br /><br />07 JS_ver.supports = function() &#160; <br /><br />08 { &#160; <br /><br />09 　　if (arguments[0]) &#160; <br /><br />10 　　　　return (!!~this.join().indexOf(arguments[0] +&quot;,&quot;) +&quot;,&quot;); &#160; <br /><br />11 　　else&#160; <br /><br />12 　　　　return (this[this.length-1]); &#160; <br /><br />13 } &#160; <br /><br />14 alert(&quot;Latest Javascript version supported: &quot;+ JS_ver.supports()); &#160; <br /><br />15 alert(&quot;Support for version 1.7 : &quot;+ JS_ver.supports(&quot;1.7&quot;));&#160; <br />5.使用window.name进行简单会话处理<br />这个是我真的喜欢的东西。您可以为指定一个字符串作为window.name属性的值，直到您关闭该标签或窗口。虽然我没有提供任何脚本，但我强烈建议您如充分利用这个方法。举例来说，在建设一个网站或应用程序的时候，在调试和测试模式之间切换是非常有用的。<br /><br />6.判断属性是否存在<br />这个问题包含两个方面，既有检查属性时候存在，还要获取属性的类型。但我们总是忽略了这些小事情:<br /><br />view sourceprint?<br />01 // BAD: This will cause an error in code when foo is undefined &#160; <br /><br />02 if (foo) { &#160; <br /><br />03 　　doSomething(); &#160; <br /><br />04 } &#160; <br /><br />05 // GOOD: This doesn't cause any errors. However, even when &#160; <br /><br />06 // foo is set to NULL or false, the condition validates as true &#160; <br /><br />07 if (typeof foo != &quot;undefined&quot;) { &#160; <br /><br />08 　　doSomething(); &#160; <br /><br />09 } &#160; <br /><br />10 // BETTER: This doesn't cause any errors and in addition &#160; <br /><br />11 // values NULL or false won't validate as true &#160; <br /><br />12 if (window.foo) { &#160; <br /><br />13 　　doSomething(); &#160; <br /><br />14 }&#160; <br />但是，有的情况下，我们有更深的结构和需要更合适的检查的时候，可以这样：<br /><br />view sourceprint?<br />1 // UGLY: we have to proof existence of every &#160; <br /><br />2 // object before we can be sure property actually exists &#160; <br /><br />3 if (window.oFoo &amp;&amp; oFoo.oBar &amp;&amp; oFoo.oBar.baz) { &#160; <br /><br />4 　　doSomething(); &#160; <br /><br />5 }&#160; <br />7.给函数传递参数<br />当函数既有必选又有可选参数的时候，我们可能是这样做的：<br /><br />view sourceprint?<br />1 function doSomething(arg0, arg1, arg2, arg3, arg4) { &#160; <br /><br />2 　　... &#160; <br /><br />3 } &#160; <br /><br />4 doSomething('', 'foo', 5, [], false);&#160; <br />而传递一个对象总是比传递一堆的参数更方便：<br /><br />view sourceprint?<br />01 function doSomething() { &#160; <br /><br />02 　　// Leaves the function if nothing is passed &#160; <br /><br />03 　　if (!arguments[0]) { &#160; <br /><br />04 　　return false; &#160; <br /><br />05 　　} &#160; <br /><br />06 　　var oArgs   = arguments[0] &#160; <br /><br />07 　　arg0    = oArgs.arg0 || &quot;&quot;, &#160; <br /><br />08 　　arg1    = oArgs.arg1 || &quot;&quot;, &#160; <br /><br />09 　　arg2    = oArgs.arg2 || 0, &#160; <br /><br />10 　　arg3    = oArgs.arg3 || [], &#160; <br /><br />11 　　arg4    = oArgs.arg4 || false; &#160; <br /><br />12 } &#160; <br /><br />13 doSomething({ &#160; <br /><br />14 　　arg1    : &quot;foo&quot;, &#160; <br /><br />15 　　arg2    : 5, &#160; <br /><br />16 　　arg4    : false&#160; <br /><br />17 });&#160; <br />这只是一个把对象作为参数传递的一个很简单的例子，例如，我们还可以声明一个对象，变量名作为Key，默认值作为Value。<br /><br />8.使用document.createDocumentFragment()<br />您可能需要动态地追加多个元素到文档中。然而，直接将它们插入到文档中会导致这个文档每次都需要重新布局一个，相反的，你应该使用文档碎片，建成后只追加一次：<br /><br />view sourceprint?<br />01 function createList() { &#160; <br /><br />02 　　var aLI = [&quot;first item&quot;, &quot;second item&quot;, &quot;third item&quot;, &#160; <br /><br />03 　　&quot;fourth item&quot;, &quot;fith item&quot;]; &#160; <br /><br />04 　　// Creates the fragment &#160; <br /><br />05 　　var oFrag   = document.createDocumentFragment(); &#160; <br /><br />06 　　while (aLI.length) { &#160; <br /><br />07 　　　　var oLI = document.createElement(&quot;li&quot;); &#160; <br /><br />08 　　　　// Removes the first item from array and appends it &#160; <br /><br />09 　　　　// as a text node to LI element &#160; <br /><br />10 　　　　oLI.appendChild(document.createTextNode(aLI.shift())); &#160; <br /><br />11 　　　　oFrag.appendChild(oLI); &#160; <br /><br />12 　　} &#160; <br /><br />13 　　document.getElementById('myUL').appendChild(oFrag); &#160; <br /><br />14 }&#160; <br />9.为replace()方法传递一个函数<br />有的时候你想替换字符串的某个部分为其它的值，最好的方法就是给String.replace()传递一个独立的函数。下面是一个简单例子：<br /><br />view sourceprint?<br />01 var sFlop   = &quot;Flop: [Ah] [Ks] [7c]&quot;; &#160; <br /><br />02 var aValues = {&quot;A&quot;:&quot;Ace&quot;,&quot;K&quot;:&quot;King&quot;,7:&quot;Seven&quot;}; &#160; <br /><br />03 var aSuits  = {&quot;h&quot;:&quot;Hearts&quot;,&quot;s&quot;:&quot;Spades&quot;, &#160; <br /><br />04 &quot;d&quot;:&quot;Diamonds&quot;,&quot;c&quot;:&quot;Clubs&quot;}; &#160; <br /><br />05 sFlop   = sFlop.replace(/\[\w+\]/gi, function(match) { &#160; <br /><br />06 　　match   = match.replace(match[2], aSuits[match[2]]); &#160; <br /><br />07 　　match   = match.replace(match[1], aValues[match[1]] +&quot; of &quot;); &#160; <br /><br />08 　　return match; &#160; <br /><br />09 }); &#160; <br /><br />10 // string sFlop now contains: &#160; <br /><br />11 // &quot;Flop: [Ace of Hearts] [King of Spades] [Seven of Clubs]&quot;&#160; <br />10.循环中标签的使用<br />有的时候，循环中又嵌套了循环，你可能想在循环中退出，则可以用标签：<br /><br />view sourceprint?<br />01 outerloop: &#160; <br /><br />02 for (var iI=0;iI&lt;5;iI++) { &#160; <br /><br />03 　　if (somethingIsTrue()) { &#160; <br /><br />04 　　// Breaks the outer loop iteration &#160; <br /><br />05 　　break outerloop; &#160; <br /><br />06 　　} &#160; <br /><br />07 　　innerloop: &#160; <br /><br />08 　　for (var iA=0;iA&lt;5;iA++) { &#160; <br /><br />09 　　　　if (somethingElseIsTrue()) { &#160; <br /><br />10 　　　　// Breaks the inner loop iteration &#160; <br /><br />11 　　　　break innerloop; &#160; <br /><br />12 　　} &#160; <br /><br />13 　　} &#160; <br /><br />14 }&#160; </div>
---
layout: post
title: 任务间的同步和进程间协调
time: 2011-07-30 17:07
tags: 好好学习天天向上
---

<div id=content class="content mod-cs-content text-content clearfix"> <blockquote><p>任务间的同步和进程间协调的几种方式:</p></blockquote><ol><ol><li><p>内存共享(Shared Memory),对简单的数据共享而言.</p></li><li><p>信号量(Semaphore),基本的互斥和同步.</p></li><li><p>消息队列(Message queues)和管道(Pipe),单个CPU中,任务间的信息传递.</p></li><li><p>套结字(Socket)和远程调用(Remote procedure calls),相对于网络任务间的通信.</p></li><li><p>信号(Signals),出错处理(Exception handling).</p><p></p><p></p><p>&nbsp; &nbsp; 1、&nbsp;<b>内存共享(Shared Memory)</b>&nbsp;&nbsp;&nbsp;<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b></p><blockquote><blockquote><p>任务间通信最通常的方式是通过共享的数据结构进行通信,因为所有VxWorks的任务存在于一个单一的线性地址空间，任务间共享数据。全局变量、线性队列、环形队列、链表、指针都可被运行在不同上下文的代码所指向。</p><a name="84955">Shared Data Structures</a><dl><a name="84952"></a><img class="figure" src="http://hiphotos.baidu.com/pengjunlong/pic/item/36ac56084a1051f20b7b824f.jpg" width="299" height="129" /></dl><p>　</p></blockquote><p><strong>互斥</strong><b>(Mutual Exclusion)</b></p><p>互斥是用来控制多任务对共享数据进行串行访问的同步机制。在多任务应用中，当两个或多个任务同时访问共享数据时，可能会造成数据破坏。互斥使它们串行地访问数据，从而达到保护数据的目的.</p><p>解决互斥的几种方法及缺点:</p><p>1. 关闭中断的方法(intLock): 能解决任务和中断ISR之间产生的互斥.但在实时系统中采取这个办法会影响系统对外部中断及时响应和处理的能力.</p><p>2. 关闭系统优先级(taskLock): 关闭系统优先级,这样在当前任务执行时,除了中断外,不会有其他优先级高的任务来抢占CPU,影响当前程序运行.这种方法阻止了高优先级的任务抢先运行,在实时系统中也是不适合的,除非关闭优先级的时间特别短.</p></blockquote><p>&nbsp;</p><blockquote><p><b>2、信号量</b><strong>(Semaphore):</strong>&nbsp;信号量是解决<strong>互斥</strong>和<strong>同步协调进程</strong>最好的方法</p><blockquote><p>VxWorks信号量提供最快速的任务间通信机制，它主要用于解决任务间的互斥和同步。针对不同类型的问题，有以下三种信号量：</p><p>&#376;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二进制信号量（<i>binary)</i>&nbsp;使用最快捷、最广泛，主要用于同步或互斥；</p><p>&#376;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;互斥信号量(<i>mutual exclusion</i>)&nbsp;&nbsp;特殊的二进制信号量，主要用于优先级继承、安全删除和回溯；</p><p>&#376;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计数器信号量(counting) 和二进制信号量类似，保持信号量被释放（gaven)的次数&nbsp;,主要用于保护一个资源的多个例程（multiple instances of a resource）<b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</b></p><ol><li><p><b>二进制信号量（<i>binary)</i>&nbsp;</b></p></li></ol><a name="90612">Taking a Semaphore</a><dl><a name="90651"></a><img class="figure" src="http://hiphotos.baidu.com/pengjunlong/pic/item/d3a574063883461c0308814f.jpg" width="351" height="141" /></dl><a name="90676">&nbsp;Giving a Semaphore</a><dl><a name="90716"></a><img class="figure" src="http://hiphotos.baidu.com/pengjunlong/pic/item/8238107b251e37930bd1874f.jpg" width="353" height="151" /></dl><p>　</p><blockquote><p><strong>互斥进程<i>（<a name="85180">Mutual Exclusion</a>）</i></strong></p><p>互斥信号量有效的内锁对共享资源的进入，与屏蔽中断(disabling interrupts)和优先级锁定（preemptive locks）相比，二进制信号量将互斥的范围限制在仅与其有关的资源上。从技术上说，创建一个信号量来保护(guarding)资源。信号量初始化位可用的（FULL）。</p><p></p></blockquote><p></p></blockquote></blockquote><p>　</p><blockquote><blockquote><ol><li><p><b>互斥信号量</b></p></li></ol><blockquote><p>互斥信号量是一个特殊的二进制信号量，设计用于优先级继承，安全删除和回归。</p><p>互斥信号量的使用基本和二进制信号量是类似的。但有以下不同：</p><ul><li><p>仅仅被用做互斥。</p></li><li><p>只能被使用它的任务释放.(It can be given only by the task that took it.)</p></li><li><p>ISR 不能释放它。</p></li><li><p>不能使用函数<i><b>semFlush</b></i><b>(&nbsp;)</b>。</p></li></ul></blockquote></blockquote><p></p><blockquote><blockquote><p><strong>优先级反转(Priority Inversion)</strong></p><blockquote><p>优先级反转是指一个任务等待比它优先级低的任务释放资源而被阻塞，如果这时有中等优先级的就绪任务（t2），阻塞会进一步恶化。优先级继承技术可用来解决优先级反转问题。</p><dl><a name="91094"></a><img class="figure" src="http://hiphotos.baidu.com/pengjunlong/pic/item/95d6180853e246b663d9864f.jpg" width="360" height="203" /></dl><p>　</p></blockquote><blockquote><p>Priority&nbsp;inversion arises when a higher-priority task is forced to wait an indefinite period of time for a lower-priority task to complete.</p></blockquote><p><strong>优先级继承(Priority Inheritance)</strong></p><blockquote><p>优先级继承可用来解决优先级反转问题。当优先级反转发生时，优先级较低的任务被暂时地提高它的优先级（t3-》t1），使得该任务能尽快执行，释放出优先级较高的任务所需要的资源。</p><a name="91101">Priority Inheritance</a><dl><a name="91135"></a><img class="figure" src="http://hiphotos.baidu.com/pengjunlong/pic/item/cea2c3f9833a2c3e242df241.jpg" width="360" height="110" /></dl><p>　</p></blockquote><blockquote><p>The mutual-exclusion semaphore has the option SEM_INVERSION_SAFE, which enables a priority-inheritance algorithm. The priority-inheritance protocol assures that a task that owns a resource executes at the priority of the highest-priority task blocked on that resource. Once the task priority has been elevated, it remains at the higher level until all mutual-exclusion semaphores that the task owns are released; then the task returns to its normal, or standard, priority. Hence, the &quot;inheriting&quot; task is protected from preemption by any intermediate-priority tasks. This option must be used in conjunction with a priority queue (SEM_Q_PRIORITY).</p></blockquote></blockquote><p></p><ol><li><p><b>计数信号量</b><i><b>（<a name="85413">Counting Semaphores</a>）</b></i></p></li></ol><blockquote><p>计数信号量是任务同步和互斥的另一种实现方式.计数信号量除了保留信号量被释放的次数以外和二进制信号量是一样的。每次信号量被释放（gaven)一次，计数增加；每次信号量被占用（taken)一次，计数减少;当计数减少为0时，要求得到信号量的任务被阻塞（blocked)。二进制信号量是如果一个信号量被释放，有一个任务阻塞等待，则这个任务就被unblock.而计数信号量如果一个信号量被释放，没有任务阻塞等待，则计数增加。这说明一个被释放两次的计数信号量可以被占用(taken)两次,没有阻塞。</p><p><a name="85488"></a>Counting semaphores are useful for guarding multiple copies of resources. For example, the use of five tape drives might be coordinated using a counting semaphore with an initial count of 5, or a ring buffer with 256 entries might be implemented using a counting semaphore with an initial count of 256. The initial count is specified as an argument to the&nbsp;<b><i>semCCreate</i></b><b>(&nbsp;)</b>routine.</p></blockquote><p>　</p></blockquote></blockquote><p>　</p><p>&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;3、&nbsp;<b>消息队列(Message queues)</b></p><blockquote><blockquote><p>现实的实时应用由一系列互相独立又协同工作的任务组成。信号量为任务间同步和联锁提供了高效机制。在VxWorks中，用于但一CPU任务之间通信主要（primary）的机制是消息队列。</p><a name="85857">Full Duplex Communication Using Message Queues</a><dl><a name="85854"></a><img class="figure" src="http://hiphotos.baidu.com/pengjunlong/pic/item/48877a59733d984d2934f041.jpg" width="313" height="139" /></dl><p>　</p><p>消息队列允许一定数量不同长度的消息进行排列。任何任务或中断服务程序(ISR)能够发送消息给消息队列。任何任务可以从消息队列接受消息。多任务可以从同意消息队列发送和接受消息。两个任务之间的全双工（Full-duplex）通信需要针对不同方向的两个消息队列。</p><i><b><a name="85951"></a></b></i><p>　</p></blockquote><p><b>管道（<i><a name="86337">Pipes</a>）</i></b></p><blockquote><p>管道对消息队列提供了一个可供选择的接口，VxWorks的I/O系统。管道是虚拟的I/O设备，由驱动<b>pipeDrv</b>管理。函数<i><b>pipeDevCreate</b></i><b>()</b>创建一个管道设备，这个调用指定管道的名字，能被排列的最多的消息数，和每个消息允许的长度。</p><p><b><a name="86340"><i>status</i>&nbsp;= pipeDevCreate (&quot;<i>/pipe/name</i>&quot;,&nbsp;<i>max_msgs</i>,&nbsp;<i>max_length</i>);</a></b></p><p>被创建的管道是一个通常命名（named)的I/O设备,任务能用标准的I/O函数打开，读，写管道，并能调用ioctl例程。当任务试图从一个空的管道中读取数据，或向一个满的管道中写入数据时，任务被阻塞。和消息队列一样，ISR可以向管道写入，但不能从管道读取。</p><p>做为I/O设备，管道提供了消息队列所没有的重要特性，调用<i><b>select()</b></i></p></blockquote></blockquote><p></p></li></ol></ol><p></p> </div>
tag=define 宏定义函数容易造成二义性问题
<div id=content class="content mod-cs-content text-content clearfix"> <p>要成为一名PHP编程高手并不容易，并不像很多人想象的那样，只要能够飞快地编写几条简单的代码去解决一个复杂的问题就是PHP编程高手了，真正的 PHP高手还需要考虑更多的其它问题。以下三条准则是一名成熟的PHP程序员在编程中应该首先遵循的准则。</p><p>◆懒惰是金</p><p>◆编写漂亮的代码</p><p>◆追求程序的速度，而不是编程的速度</p><p><strong>懒惰是金</strong></p><p>做一个懒惰的程序员吗？这个想法太奇怪了！因为这个世界上最忙碌的人可能就是计算机程序员了。但正是因为程序员太忙了，所以才应该在编程时学会偷 懒。对于一个程序员来说，懒惰的方法有两种：</p><p>其一，大胆使用现成的别人的程序代码，把这些代码融入到你自己的程序或者项目中去。其二是编写一些有用的代码建立一个函数库，在将来编写程序时可以 顺手拈来，省去了许多重复的劳动，自然就可以懒惰一点了。这两种偷懒的方法都非常适合PHP程序员了。</p><p>首先，PHP是在自由开放的环境中诞生和成长的一门语言。在世界各地，有成千上万的程序员，他们一直在为PHP的完美而不断奋斗，他们也愿意和别人 分享自己的聪明才智和自己编写的代码。你每天都可以从一些PHP网站、邮件列表、新闻组发现大量的优秀的程序代码。</p><p>这样说，我并不是鼓励你整天等着让别人为你编写代码，但是你可以“站在伟人的肩膀上”，充分发扬“拿来主义”，聪明地应用别人的程序代码可以节省你 大量时间。其次，在PHP中，你可以方便地建立自己的函数库，这样可以在你以后编写程序时省去很多麻烦。</p><p>下面笔者为大家介绍几个通用的函数，这些函数有的来自网上的一些开放源代码的项目，有的精选自邮件列表。如果你能把它们加入到你自己的函数库中，迟 早你将会发现自己受益无穷。</p><p><strong>1.通用数据库处理函数</strong></p><p>和其它的CGI函数相比，PHP的优点之一是具有很强大的数据库处理能力。但是，在PHP中，对于不同的数据库都使用一些特定的函数来专门处理，缺 少通用的数据库处理函数。这大大降低了程序代码的可移植性，这也为初学编程的朋友带来了很多不便。</p><p>在网上，许多程序员都通过封装类解决了这个问题。他们编写了统一的函数用来处理任何流行的数据库——不管是在Linux世界深受欢迎的Mysql还 是在Windows平台上广泛流行的SqlServer。</p><p>就笔者个人来说，非常喜欢使用这些函数，因为可以直接使用一些简单的诸如”query”、”next_record”之类的函数，而不需要考虑数据 库的连接、数据库句柄这些复杂的东西，更不需要考虑使用的是何种数据库。如果你需要这些函数，你可以通过访问以下的几个网址而得到：</p><p>◆http://phplib.netuse.de/</p><p>◆http://phpclasses.UpperDesign.com/browse.html/package/20</p><p>◆http://phpdb.linuxbox.com/</p><p><strong>2.变量调试函数</strong></p><p>PHP程序的调试一直是一件让人头疼的事，它既不像VB等高级语言那样有集成的编译调试环境，也不想Perl那样可以在Linux或者DOS环境下 直接运行。其实，我们完全可以通过灵活地使用echo语句来完成对PHP的调试工作。下面的几个函数可以让你随时查看程序中任何变量的类型及其值。</p><ol><li>function&#160;ss_array_as_string&#160;(＆$array,&#160;$column&#160;=&#160;0)&#160;{ &#160;</li><li>　$str&#160;=&#160;“Array(n”; &#160;</li><li>while(list($var,&#160;$val)&#160;=&#160;each($array)){ &#160;</li><li>　for&#160;($i&#160;=&#160;0;&#160;$i&#160;&lt;&#160;$column＋1;&#160;$i＋＋){ &#160;</li><li>$str&#160;.=&#160;“＆nbsp;＆nbsp;＆nbsp;＆nbsp;”; &#160;</li><li>　} &#160;</li><li>　$str&#160;.=&#160;$var.&#160;==＞&#160;; &#160;</li><li>　$str&#160;.=&#160;ss_as_string($val,&#160;$column＋1).”&#160;n”; &#160;</li><li>} &#160;</li><li>for&#160;($i&#160;=&#160;0;&#160;$i&#160;&lt;&#160;$column;&#160;$i＋＋){ &#160;</li><li>　$str&#160;.=&#160;“＆nbsp;＆nbsp;＆nbsp;＆nbsp;”; &#160;</li><li>} &#160;</li><li>return&#160;$str.); &#160;</li><li>　} &#160;</li><li>　function&#160;ss_object_as_string&#160;(＆$object,&#160;$column&#160;=&#160;0)&#160;{ &#160;</li><li>if&#160;(empty($object－＞classname))&#160;{ &#160;</li><li>　return&#160;“$object”; &#160;</li><li>} &#160;</li><li>else&#160;{ &#160;</li><li>　$str&#160;=&#160;$object－＞classname.”(&#160;n”; &#160;</li><li>while&#160;(list(,$var)&#160;=&#160;each($object－＞persistent_slots))&#160;{ &#160;</li><li>　for&#160;($i&#160;=&#160;0;&#160;$i&#160;&lt;&#160;$column;&#160;$i＋＋){ &#160;</li><li>$str&#160;.=&#160;“＆nbsp;＆nbsp;＆nbsp;＆nbsp;”; &#160;</li><li>　} &#160;</li><li>　global&#160;$$var; &#160;</li><li>　$str&#160;.=&#160;$var.&#160;==＞&#160;; &#160;</li><li>　$str&#160;.=&#160;ss_as_string($$var,&#160;column＋1).”&#160;n”; &#160;</li><li>} &#160;</li><li>for&#160;($i&#160;=&#160;0;&#160;$i&#160;&lt;&#160;$column;&#160;$i＋＋){ &#160;</li><li>　$str&#160;.=&#160;“＆nbsp;＆nbsp;＆nbsp;＆nbsp;”; &#160;</li><li>} &#160;</li><li>return&#160;$str.); &#160;</li><li>} &#160;</li><li>　} &#160;</li><li>　function&#160;ss_as_string&#160;(＆$thing,&#160;$column&#160;=&#160;0)&#160;{ &#160;</li><li>　if&#160;(is_object($thing))&#160;{ &#160;</li><li>return&#160;ss_object_as_string($thing,&#160;$column); &#160;</li><li>　} &#160;</li><li>　elseif&#160;(is_array($thing))&#160;{ &#160;</li><li>return&#160;ss_array_as_string($thing,&#160;$column); &#160;</li><li>　} &#160;</li><li>　elseif&#160;(is_double($thing))&#160;{ &#160;</li><li>return&#160;“Double(“.$thing.”)”; &#160;</li><li>　} &#160;</li><li>　elseif&#160;(is_long($thing))&#160;{ &#160;</li><li>return&#160;“Long(“.$thing.”)”; &#160;</li><li>　} &#160;</li><li>　elseif&#160;(is_string($thing))&#160;{ &#160;</li><li>return&#160;“String(“.$thing.”)”; &#160;</li><li>　} &#160;</li><li>　else&#160;{ &#160;</li><li>return&#160;“Unknown(“.$thing.”)”; &#160;</li><li>　} &#160;</li><li>　}&#160;</li></ol><p>需要的时候，在程序中简单地加入下面的一条代码即可查看程序中的所使用的变量（包括数组和对象）的类型和值：</p><ol><li>echo&#160;ss_as_string($my_variable);&#160;</li><li>&#160;</li></ol><p>使用下面的语句，我们可以直接查看程序中所有的变量的值：</p><ol><li>echo&#160;ss_as_string($GLOBALS);</li><li>&#160;</li></ol><p><strong>3. 控制Log信息的函数</strong></p><p>调试PHP程序的另外一种重要的方法就是查看Log信息。如果能够方便地控制Log信息的级别以及Log信息的显示内容，将会给程序调试带来更多的 便利。下面的几个函数可以方便地实现这个功能。</p><ol><li>$ss_log_level&#160;=&#160;0; &#160;</li><li>$ss_log_filename&#160;=&#160;/tmp/ss－log; &#160;</li><li>$ss_log_levels&#160;=&#160;array( &#160;</li><li>　NONE&#160;=＞&#160;0, &#160;</li><li>　ERROR&#160;=＞&#160;1, &#160;</li><li>　INFO&#160;=＞&#160;2, &#160;</li><li>　DEBUG&#160;=＞&#160;3); &#160;</li><li>function&#160;ss_log_set_level&#160;($level&#160;=&#160;ERROR)&#160;{ &#160;</li><li>　global&#160;$ss_log_level; &#160;</li><li>　$ss_log_level&#160;=&#160;$level; &#160;</li><li>} &#160;</li><li>function&#160;ss_log&#160;($level,&#160;$message)&#160;{ &#160;</li><li>　global&#160;$ss_log_level,&#160;$ss－log－filename; &#160;</li><li>　if&#160;($ss_log_levels[$ss_log_level]&#160;&lt;&#160;$ss_log_levels[$level])&#160;{ &#160;</li><li>//&#160;不显示Log信息 &#160;</li><li>return&#160;false; &#160;</li><li>　} &#160;</li><li>　$fd&#160;=&#160;fopen($ss_log_filename,&#160;“a＋”); &#160;</li><li>　fputs($fd,&#160;$level.&#160;－&#160;[.ss_timestamp_pretty().]&#160;－&#160;.$message.”n”); &#160;</li><li>　fclose($fd); &#160;</li><li>　return&#160;true; &#160;</li><li>} &#160;</li><li>function&#160;ss_log_reset&#160;()&#160;{ &#160;</li><li>　global&#160;$ss_log_filename; &#160;</li><li>　@unlink($ss_log_filename); &#160;</li><li>}&#160;</li></ol><p>在上面的函数中，有四个Log级别变量。运行PHP程序时，只有当Log的级别低于预设的级别值时，Log信息才可以被记录和显示出来。例如，在程 序中加入如下的一条语句：</p><ol><li>ss_log_set_level(INFO);&#160;</li><li>&#160;</li></ol><p>那么，运行PHP程序时，只有ERROR和INFO级别的LOG信息才能被记录和显示出来，DEBUG级的信息则被忽略了。除此之外，我们还可以设 定显示的信息内容，其语句如下：</p><ol><li>ss_log(ERROR,&#160;“testing&#160;level&#160;ERROR”); &#160;</li><li>ss_log(INFO,&#160;“testing&#160;level&#160;INFO”); &#160;</li><li>ss_log(DEBUG,&#160;“testing&#160;level&#160;DEBUG”);&#160;</li></ol><p>你也可以随时使用下面的语句清空LOG信息：</p><ol><li>ss_log_reset();&#160;</li><li>&#160;</li></ol><p><strong>4.速度测试函数</strong></p><p>为了优化代码，我们需要一种可以测试代码运行时间的方法，从而来选择最优的代码。下面的函数可以测试运行代码所需的时间：</p><ol><li>function&#160;ss_timing_start&#160;($name&#160;=&#160;default)&#160;{ &#160;</li><li>　global&#160;$ss_timing_start_times; &#160;</li><li>　$ss_timing_start_times[$name]&#160;=&#160;explode(&#160;,&#160;microtime()); &#160;</li><li>} &#160;</li><li>function&#160;ss_timing_stop&#160;($name&#160;=&#160;default)&#160;{ &#160;</li><li>　global&#160;$ss_timing_stop_times; &#160;</li><li>　$ss_timing_stop_times[$name]&#160;=&#160;explode(,&#160;microtime()); &#160;</li><li>} &#160;</li><li>function&#160;ss_timing_current&#160;($name&#160;=&#160;default)&#160;{ &#160;</li><li>　global&#160;$ss_timing_start_times,&#160;$ss_timing_stop_times; &#160;</li><li>　if&#160;(!isset($ss_timing_start_times[$name]))&#160;{ &#160;</li><li>return&#160;0; &#160;</li><li>　} &#160;</li><li>　if&#160;(!isset($ss_timing_stop_times[$name]))&#160;{ &#160;</li><li>$stop_time&#160;=&#160;explode(,&#160;microtime()); &#160;</li><li>　} &#160;</li><li>　else&#160;{ &#160;</li><li>$stop_time&#160;=&#160;$ss_timing_stop_times[$name]; &#160;</li><li>　} &#160;</li><li>　$current&#160;=&#160;$stop_time[1]&#160;－&#160;$ss_timing_start_times[$name][1]; &#160;</li><li>　$current&#160;＋=&#160;$stop_time[0]&#160;－&#160;$ss_timing_start_times[$name][0]; &#160;</li><li>　return&#160;$current; &#160;</li><li>}&#160;</li></ol><p>现在可以轻松地检查任何一段代码的执行时间了，甚至我们可以同时使用多个计时器，只需在使用上述的几个函数时设定不同的参数作为计时器的名称就可以 了。</p><p><strong>5.调试和优化数据库的操作</strong></p><p>对于数据库来说，运行速度是至关重要的。尽管很多书籍和文章都讲授了一些快速运行数据库的方法，但是所有的方法都必须经过实践的检验。下面我们将把 PHPLib函数库中的query()函数和上面介绍的几个函数综合起来编写成新的query()函数，和原先的函数相比，这个函数增加了运行时间的监测 功能。</p><ol><li>function&#160;query($Query_String,&#160;$halt_on_error&#160;=&#160;1)&#160;{ &#160;</li><li>　$this－＞connect(); &#160;</li><li>　ss_timing_start(); &#160;</li><li>　$this－＞Query_ID&#160;=&#160;@mysql_query($Query_String,$this－＞Link_ID); &#160;</li><li>　ss_timing_stop(); &#160;</li><li>　ss_log(INFO,&#160;ss_timing_current().&#160;Secs&#160;－&#160;.$Query_String); &#160;</li><li>　$this－＞Row&#160;=&#160;0; &#160;</li><li>　$this－＞Errno&#160;=&#160;mysql_errno(); &#160;</li><li>　$this－＞Error&#160;=&#160;mysql_error(); &#160;</li><li>　if&#160;($halt_on_error&#160;＆＆&#160;!$this－＞Query_ID)&#160;{ &#160;</li><li>$this－＞halt(“Invalid&#160;SQL:&#160;“.$Query_String); &#160;</li><li>　} &#160;</li><li>　return&#160;$this－＞Query_ID; &#160;</li><li>} <br /></li></ol><p><strong>编写漂亮的代码</strong></p><p><strong>1.将后台程序与前端程序分开</strong></p><p>在编写PHP程序时，有些代码是用来处理一些事务，例如操作数据库、进行数学运算等，而另外的一些代码则只是事务处理的结果显示出来，例如一些使用 echo语句将结果以HTML的格式显示在Web浏览器上的PHP代码以及那些直接嵌入PHP程序的HTML代码。首先我们应该清晰地区分这两种代码，把 前者称为后台程序，把后者称为前端程序。</p><p>因为PHP是一种嵌入式编程语言，也就是说，所有的PHP代码都可以嵌入到HTML代码之中，这为程序的编写带来了许多便利之处。但是，“物极必 反”，如果在一段较长的程序中将PHP代码和HTML代码混合编写，这将使程序杂乱无章，不利于程序的维护和阅读。</p><p>所以我们需要尽可能地将这些程序中混杂于HTML代码中的PHP代码移植出来，在专门的文件中将这些代码封装成函数，然后在HTML代码中使用 include语句来包含这些文件，在适当的位置调用这些函数即可。</p><p>这种做法一方面使HTML代码和PHP代码都简单易读，另一方面因为HTML代码需要不断更新，而这种分离的方法可以确保后台程序不会被破坏。同前 端程序不同，后台程序更多追求的是稳定、结构化，极少更改，所以应该认真地设计和管理。其实，在设计台程序时，投入大量时间是值得的，“现在栽树，以后乘 凉”，在以后的设计工作中将可以轻松地使用现在编写的后台程序。</p><p><strong>2.灵活使用包含文件</strong></p><p>正如前面所说的那样后台程序应当安排在一系列的包含文件中。包含文件可以通过include语句在需要时动态装入，也可以在php.ini文件中通 过使用auto_prepend_file指令预先自动装入。如果使用后一种方法的话，虽然取得了一劳永逸的好处，但是也有一些缺点值得我们注意。下面的 一段代码向我们展示了解析一个庞大的包含文件需要一定的时间：</p><ol>    <li>require(timing.inc);&#160; &#160;</li>    <li>ss_timing_start();&#160; &#160;</li>    <li>include(test.inc);&#160; &#160;</li>    <li>ss_timing_stop();&#160; &#160;</li>    <li>echo&#160; &#160;</li>    <li>.ss_timing_current().&#160; &#160;</li>    <li>;&#160; &#160;</li>    <li>?&gt;&#160;</li></ol><p>在上面的代码中，test.inc是一个1000行的包含文件，运行的结果显示，解析这个包含文件花费了0.6秒钟，对于一个大型网站来说，这个速 度并不是可以忽略不记的。使用包含文件的另外一个缺点是：如果一个文件中的一个语句发生错误，将会使整个网站的PHP程序都无法运行。所以使用起来也及其 小心。其实，对包含文件稍做处理，即可以使包含文件只在需要时进行解析。下面的代码使abc.inc文件只在程序需要时才作解析：</p><ol>    <li>if&#160;(&#160;defined(&#160;__LIBA_INC)&#160;)&#160;return;&#160; &#160;</li>    <li>define(&#160;__LIBA_INC,&#160;1&#160;);&#160; &#160;</li>    <li>/＊&#160; &#160;</li>    <li>＊&#160;代码...&#160; &#160;</li>    <li>＊/&#160; &#160;</li>    <li>?&gt;&#160;</li></ol><p><strong>3.使用面向对象的编程方法</strong></p><p>PHP也是一种面向对象的语言，面向对象的编程方法是优秀的程序员们非常推崇的一种软件设计方法，在PHP编程中可以充分发挥面向对象语言的优势， 对编程中的对象进行封装。在前面的代码中，我们使用了面向对象的方法，例如在管理数据库时，我们将query()函数封装进数据库类中，这极大地方便了代 码的管理，增加了程序的可读性。</p><p> </p><p><strong>追求程序速度，而不是编程的速度</strong></p><p>在网站建设中，程序运行速度和网页下载速度都是关系成败的重要因素。作为一名Web程序员，应该更加注意代码的运行速度。下面介绍的几种方法都在不 同程度上提高了代码的运行速度。</p><p><strong>1.使用内嵌的HTML代码，而不是PHP的echo语句。</strong></p><p>因为PHP是一门嵌入式Web编程语言，可以将HTML代码和PHP代码相互嵌入。但是很多程序员担心在HTML代码中过多的使用&quot;&quot;嵌入PHP代 码会多次调用PHP解释器，从而降低了PHP代码的运行速度，所以宁愿使用PHP的echo语句来输出HTML代码，而不直接使用HTML代码。</p><p>但事实却恰恰相反。每一个PHP页面只调用一次PHP解释器来解释所有的PHP代码，所以，只在需要时才嵌入PHP代码，而大多数的时候直接使用 HTML代码输入结果，不但不会降低程序的运行速度，而且因为减少了对echo语句的解析，往往可以提高代码的运行速度。下面的一段代码证明了我们的结 论。在这段代码中，我们使用了前面介绍的时间测试函数。</p><p><strong>2.使用str－replace而不是ereg－replace</strong></p><p>习惯使用Perl进行编程的程序员更加愿意使用ereg_replace完成字符串替换工作，因为在PHP中ereg_replace的用法和 Perl中模式匹配的用法相近。但是，下面的这段代码证明，使用str_replace 代替  ereg_replace将可以大大提高代码的运行速度。测试str_replace和ereg_replace的运行速度：</p><ol><li>//这段代码测试str_replace的运行速度&#160;emphasis;&#160;?&gt;&#160; &#160;</li><li>for&#160;(＄i=0;&#160;＄i&lt;1000;&#160;＄i＋＋)&#160;{&#160; &#160;</li><li>str_replace(i&gt;,&#160;b&gt;,&#160;＄string).&#160; &#160;</li><li>;&#160; &#160;</li><li>}&#160; &#160;</li><li>?&gt;&#160; &#160;</li><li>//这段代码测试ereg_replace的运行速度&#160; &#160;</li><li>for&#160;(＄i=0;&#160;＄i&lt;1000;&#160;＄i＋＋)&#160;{&#160; &#160;</li><li>ereg_replace(&lt;([/]＊)i&gt;,&#160;&lt;\\1b&gt;,&#160;＄string).&#160; &#160;</li><li>;&#160; &#160;</li><li>}&#160; &#160;</li><li>?&gt;&#160;</li></ol><p><strong>3.注意字符串的引用</strong></p><p>PHP和其它很多编程语言一样，可以使用双引号（\&quot;\&quot;）来引用字符串，也可以使用单引号（）。但是在PHP中，如果使用双引号来引用字符串，那 么PHP解析器将首先分析字符串中有没有对变量的引用，有变量的话，将对变量进行替换。如果是单引号，则没有如此复杂——直接将单引号包含起来的所有字符 串直接显示出来。显然，在PHP编程中，如果使用单引号引用字符串变量要比使用双引号快速一些。</p><p><strong>4.在数据库中避免使用联合操作</strong></p><p>比起其它的Web编程语言来说，PHP的数据库功能十分强大。但是在PHP中数据库的运行仍然是一件十分费时费力的事情，所以，作为一个Web程序 员，要尽量减少数据库的查询操作，同时应该为数据库建立适当的索引。</p><p>另一件值得注意的事情是在用PHP操作数据库时，尽可能不使用多个数据表的联合操作，尽管联合操作可以增强数据库的查询功能，但是却大大增加了服务 器的负担。为了说明这个问题，我们可以看看下面的这个简单的例子。</p><p>我们在数据库中创建了两个数据表foo和big_foo。在数据表foo中，只有一个字段，包含了从1－1000之间的所有自然数。数据表 big_foo同样只有一个字段，但包含了从1－1,000,000之间的全部自然数。所以，从大小上说，big_foo等于foo与它自身进行了联合操 作。</p><ol><li>＄db－&gt;query(\&quot;select&#160;＊&#160;from&#160;foo\&quot;);&#160; &#160;</li><li>0.032273&#160;secs&#160; &#160;</li><li>＄db－&gt;next_record();&#160; &#160;</li><li>0.00048999999999999&#160;secs&#160; &#160;</li><li>＄db－&gt;query(\&quot;insert&#160;into&#160;foo&#160;values&#160;(NULL)\&quot;);&#160; &#160;</li><li>0.019506&#160;secs&#160; &#160;</li><li>＄db－&gt;query(\&quot;select&#160;＊&#160;from&#160;foo&#160;as&#160;a,&#160;foo&#160;as&#160;b\&quot;);&#160; &#160;</li><li>17.280596&#160;secs&#160; &#160;</li><li>＄db－&gt;query(\&quot;select&#160;＊&#160;from&#160;foo&#160;as&#160;a,&#160;foo&#160;as&#160;b&#160;where&#160;a.id&#160;&gt;&#160;b.id\&quot;);&#160; &#160;</li><li>14.645251&#160;secs&#160; &#160;</li><li>＄db－&gt;query(\&quot;select&#160;＊&#160;from&#160;foo&#160;as&#160;a,&#160;foo&#160;as&#160;b&#160;where&#160;a.id&#160;=&#160;b.id\&quot;);&#160; &#160;</li><li>0.041269&#160;secs&#160; &#160;</li><li>＄db－&gt;query(\&quot;select&#160;＊&#160;from&#160;big_foo\&quot;);&#160; &#160;</li><li>25.393672&#160;secs&#160;</li></ol><p>从上面操作结果我们可以发现，对于两个有1000条记录的数据表进行联合，其速度并不比对一个1000000条纪录的大型数据表单独进行操作快多 少。</p><p><strong>5.注意include与require的区别</strong></p><p>在PHP变成中，include()与require()的功能相同，但在用法上却有一些不同，include()是有条件包含函数，而 require()则是无条件包含函数。例如在下面的一个例子中，如果变量＄somgthing为真，则将包含文件somefile：</p><ol><li>if(＄something){&#160; &#160;</li><li>include(\&quot;somefile\&quot;);&#160; &#160;</li><li>}&#160;</li></ol><p>但不管＄something取何值，下面的代码将把文件somefile包含进文件里：</p><ol><li>if(＄something){&#160; &#160;</li><li>require(\&quot;somefile\&quot;);&#160; &#160;</li><li>}&#160;</li></ol><p>下面的这个有趣的例子充分说明了这两个函数之间的不同。</p><ol><li>＄i&#160;=&#160;1;&#160; &#160;</li><li>while&#160;(＄i&#160;&lt;&#160;3)&#160;{&#160; &#160;</li><li>require(\&quot;somefile.＄i\&quot;);&#160; &#160;</li><li>＄i＋＋;&#160; &#160;</li><li>}&#160;</li></ol><p>在这段代码中，每一次循环的时候，程序都将把同一个文件包含进去。很显然这不是程序员的初衷，从代码中我们可以看出这段代码希望在每次循环时，将不 同的文件包含进来。如果要完成这个功能，必须求助函数include();</p><ol><li>＄i&#160;=&#160;1;&#160; &#160;</li><li>while&#160;(＄i&#160;&lt;&#160;3)&#160;{&#160; &#160;</li><li>include(\&quot;somefile.＄i\&quot;);&#160; &#160;</li><li>＄i＋＋;&#160; &#160;</li><li>}&#160;</li></ol><p><strong>6.注意echo和print的区别</strong></p><p>PHP中echo和print的功能也基本相同，但是两者之间也有细微差别。在PHP代码中可以把print作为一个普通函数来使用，例如执行下面 的代码后变量＄res的值将为1。</p><ol><li>$ret&#160;=&#160;print&#160;\&quot;Hello&#160;World\&quot;;</li><li>&#160;</li></ol><p>这意味着print可用在一些复杂的表达式中，而echo则不行。同样，在代码中echo语句的运行速度要略微快于print语句，因为echo语 句不要求返回任何数值。</p> </div>
---
layout: post
title: TFTP编程之服务器篇TftpS.cpp
time: 2008-09-11 13:07
tags: 
---

<div id=content class="content mod-cs-content text-content clearfix"> <p>/**************************************************************/<br />/*TFTP_server*/<br />/**************************************************************/</p><p>#define _VC /* if compile under visiual c++ else undefine this*/<br />#include &lt;stdlib.h&gt;<br />#include &lt;stdio.h&gt;</p><p>#include &lt;winsock.h&gt;<br />#include &lt;conio.h&gt;</p><p>#ifdef _VC<br />#pragma comment( lib, &quot;Wsock32.lib&quot; ) //链接时必须增加wsock32.lib库<br />#endif</p><p>#include &quot;makepack.h&quot;<br />#include &quot;log.h&quot;<br />#include &quot;time.h&quot;</p><p><br />void download(struct sockaddr_in sour_addr,char buffer[]);<br />void upload(struct sockaddr_in sour_addr,char buffer[]);<br />int login(struct sockaddr_in sour_addr,char name[]);</p><p> </p><p>SOCKET sock = INVALID_SOCKET;&nbsp;&nbsp; /*#define INVALID_SOCKET  (SOCKET)(~0)*/<br />//char desthost[256] = &quot;118.229.128.57&quot;; /*目的主机地址，默认为本机*/<br />int  filemode = TFTP_OCTET;&nbsp;&nbsp;&nbsp; /*发送模式设置为octet*/</p><p><br />int main(int argc, char* argv[])<br />{<br /> printf(&quot;sizeof(unsigned short)=%d\t\t&quot;,sizeof(unsigned short));<br /> printf(&quot;sizeof(htons(1))=%d\n&quot;,sizeof(htons(1)));<br /> printf(&quot;sizeof(int)=%d\t\t\t\t&quot;,sizeof(int));<br /> printf(&quot;sizeof(long)=%d\n&quot;,sizeof(long));<br /> printf(&quot;sizeof(double)=%d\t\t\t&quot;,sizeof(double));<br /> printf(&quot;sizeof(char)=%d\n&quot;,sizeof(char));<br /> </p><p> printf(&quot;*******************************************************\n\n\<br />\t\tTFTP_server v1.1\n\n\<br />*******************************************************\n\n请输入允许使用您的服务器的用户名：\n&quot;);<br /> char name[20];<br /> gets(name);<br /> printf(&quot;开始等待用户端请求...\n&quot;);<br />&nbsp;&nbsp;&nbsp;  int ret = 0; <br /> sockaddr_in addr;</p><p> WSADATA stWSAData;<br /> if(WSAStartup(WSA_VERSION, &amp;stWSAData)!=0){ /*启用winsock*/<br />&nbsp;&nbsp; printf(&quot;Can't start Socket \n&quot;);<br />&nbsp;&nbsp; exit(0);<br /> }<br />&nbsp;&nbsp;&nbsp;  /*创建一个数据报类型的socket*/ <br />&nbsp;&nbsp;&nbsp;  sock = socket( AF_INET,// 地址族 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SOCK_DGRAM,// socket类型,创建原始套接字 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0);// 协议类型：UDP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <br /> if(sock==INVALID_SOCKET){<br />&nbsp;&nbsp; printf(&quot;socket()失败&quot;); <br />&nbsp;&nbsp; exit(0);&nbsp;&nbsp;&nbsp; //错误处理</p><p> }<br /> <br /> /*初始化地址信息<br /> struct sockaddr_in {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  short&nbsp;&nbsp;  sin_family;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  u_short sin_port;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  struct  in_addr sin_addr;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  char&nbsp;&nbsp;&nbsp;  sin_zero[8];<br /> };*/<br /> addr.sin_family = AF_INET;<br /> addr.sin_port = htons(69);&nbsp;&nbsp;&nbsp; //服务器默认UDP端口69简单地说,htons()就是将一个数的高低位互换(如:12 34 --&gt; 34 12)</p><p> <br /> addr.sin_addr.s_addr  = INADDR_ANY; //  INADDR_ANY得到本地主机ip地址<br /> /*将服务器端口与创建的socket绑定*/<br /> if(bind(sock,(struct sockaddr *)&amp;addr,sizeof(addr))!=0){<br />&nbsp;&nbsp; printf(&quot;bind()失败&quot;); <br />&nbsp;&nbsp; exit(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //错误处理 <br /> }</p><p><br /> //初始化远程地址信息<br /> struct sockaddr_in sour_addr;<br /> sour_addr.sin_family = AF_INET;<br /> sour_addr.sin_port = htons(INADDR_ANY);<br /> //sour_addr.sin_addr.s_addr = inet_addr(desthost); // 远程IP地址</p><p> /* 在主循环中发送与接收数据*/ <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <br /> while(true) {<br />&nbsp;&nbsp; //准备接收数据 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  <br />&nbsp;&nbsp; //定义TFTP首部缓冲区<br />&nbsp;&nbsp; char recv_buffer[1024] = {0};&nbsp;&nbsp;&nbsp; // 初始化接收的数据缓冲区</p><p>&nbsp;&nbsp; int sour_len = 0;<br />&nbsp;&nbsp; int pass;<br />&nbsp;&nbsp; char *fi=NULL;</p><p>&nbsp;&nbsp; fd_set  fdr;<br />&nbsp;&nbsp; FD_ZERO(&amp;fdr);<br />&nbsp;&nbsp; FD_SET(sock, &amp;fdr);</p><p>&nbsp;&nbsp; ret = select(sock, &amp;fdr, NULL,NULL, NULL);<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp; if(SOCKET_ERROR==ret){&nbsp;&nbsp;&nbsp;&nbsp; /*#define SOCKET_ERROR&nbsp;&nbsp;  (-1)*/<br />&nbsp;&nbsp;&nbsp; printf(&quot;Socket error \n&quot;);<br />&nbsp;&nbsp;&nbsp; return 0;<br />&nbsp;&nbsp; }<br />&nbsp;&nbsp; else{<br />&nbsp;&nbsp;&nbsp; if(FD_ISSET(sock,&amp;fdr)){<br />&nbsp;&nbsp;&nbsp;&nbsp; sour_len = sizeof(sockaddr);<br />&nbsp;&nbsp;&nbsp;&nbsp; ret = recvfrom(sock,// 已绑定的socket <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; recv_buffer, // 接收缓冲区 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(recv_buffer),// 缓冲区大小 <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,// Flags <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (sockaddr *)&amp;sour_addr, // 接收客户端地址的缓冲区<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;sour_len);// 地址缓冲区的长度 <br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp; fi=&amp;recv_buffer[2];<br />&nbsp;&nbsp;&nbsp;&nbsp; if(TFTP_RRQ==recv_buffer[1]){ //读请求</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;收到%s下载文件请求\n&quot;,inet_ntoa(sour_addr.sin_addr));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass=login(sour_addr,name);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pass==1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record(3,&amp;sour_addr,fi);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; download(sour_addr,recv_buffer);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;  if(TFTP_WRQ==recv_buffer[1]){ //写请求</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;收到%s上传文件请求\n&quot;,inet_ntoa(sour_addr.sin_addr));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass=login(sour_addr,name);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(pass==1)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record(1,&amp;sour_addr,fi);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; upload(sour_addr,recv_buffer);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }//end if<br />&nbsp;&nbsp; }//end else<br /> }//end while<br /> return 0;<br />}</p><p>int login(struct sockaddr_in sour_addr,char name[])<br />{<br /> int sour_len = sizeof(sockaddr);<br /> char sendbuf[]=&quot;请输入用户名：\n&quot;;<br /> char recvbuf[20];<br /> memset(recvbuf,'\0',sizeof(recvbuf));<br /> sendto(sock,sendbuf,sizeof(sendbuf),0,(sockaddr *)&amp;sour_addr,sizeof(sour_addr));<br /> recvfrom(sock,recvbuf,sizeof(recvbuf),0,(sockaddr *)&amp;sour_addr,&amp;sour_len);<br /> if(strcmp(recvbuf,name)==0)<br /> {<br />&nbsp;&nbsp; char sendbuf[]=&quot;用户名正确!!!\n&quot;;<br />&nbsp;&nbsp; printf(sendbuf);<br />&nbsp;&nbsp; sendto(sock,sendbuf,sizeof(sendbuf),0,(sockaddr *)&amp;sour_addr,sizeof(sour_addr));<br />&nbsp;&nbsp; return 1;<br /> }<br /> else<br /> {<br />&nbsp;&nbsp; char sendbuf[]=&quot;用户名错误!!!\n&quot;;<br />&nbsp;&nbsp; printf(sendbuf);<br />&nbsp;&nbsp; sendto(sock,sendbuf,sizeof(sendbuf),0,(sockaddr *)&amp;sour_addr,sizeof(sour_addr));<br />&nbsp;&nbsp; return 0;<br /> }<br />}</p><p> </p><p>//RRQ (客户端要读取文件)<br />void download(struct sockaddr_in sour_addr,char buffer[])<br />{<br /> int wrong=0;<br /> int retry = 0;<br /> int sour_len = 0;<br /> int ret = 0;<br /> int len = 0 ;<br /> int flen = 0;<br /> int stat = TFTP_WSTAT_NEXTACK;<br /> unsigned short lastack= 0;<br /> unsigned short blocknum = 0;<br /> char send_buffer[1024] = {0};<br /> char recv_buffer[1024] = {0};<br /> char data_buffer[1024] = {0};<br /> char filename[256];<br /> struct  timeval timeout = {10,0};//{秒,微秒}select等待10秒，10秒轮询，要非阻塞就置0<br /> <br /> fd_set  fdr;<br /> size_t rlen = 0;<br /> FILE *file;</p><p> <br /> //printf(&quot;端口号:%d\n&quot;,ntohs(sour_addr.sin_port));<br /> //printf(&quot;ip地址:%s\n&quot;,inet_ntoa(sour_addr.sin_addr));<br /> <br /> strcpy(filename,buffer+2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /*获取文件名*/<br /> printf(&quot;获取文件名:%s\n&quot;,filename);<br /> printf(&quot;开始读取文件...\n&quot;);<br /> if((file=fopen(filename,&quot;rb&quot;))==NULL)<br /> {<br />&nbsp;&nbsp; printf(&quot;File %s not found \n&quot;,filename);<br />&nbsp;&nbsp; record(5,&amp;sour_addr,filename);<br />&nbsp;&nbsp; return;<br /> }</p><p> rlen = fread(data_buffer,1,512,file);&nbsp;&nbsp; /*返回值：成功读取的元素个数*/<br /> flen = flen + rlen;<br /> if(rlen&lt;512 &amp;&amp; feof(file))<br /> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //feof功 能: 检测流上的文件结束符<br />&nbsp;&nbsp; stat = TFTP_WSTAT_LASTACK;&nbsp;&nbsp;&nbsp;&nbsp; //文件最后一块<br /> }<br /> else<br /> {<br />&nbsp;&nbsp; if(ferror(file))<br />&nbsp;&nbsp; {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //ferror功  能: 检测流上的错误<br />&nbsp;&nbsp;&nbsp; fclose(file);<br />&nbsp;&nbsp;&nbsp; record(6,&amp;sour_addr,filename);<br />&nbsp;&nbsp;&nbsp; return;<br />&nbsp;&nbsp; }<br /> }<br />&nbsp;&nbsp; blocknum++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //文件下一块<br />&nbsp;&nbsp; len = makedata(blocknum,data_buffer,rlen,send_buffer,sizeof(send_buffer));<br />&nbsp;&nbsp; if(rand()%100&gt;=2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //发送第一块<br />&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; ret = sendto(sock,//SOCKET<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; send_buffer,//包含要发送的数据<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len,//要发送的字节数<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,//socketFlags <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (sockaddr *)&amp;sour_addr,//目的地址的缓冲区<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof(sour_addr));//目的地址的大小<br />&nbsp;&nbsp;&nbsp; //printf(&quot;***DATA#%d&nbsp;&nbsp; %d byte has sended，目前总共%d byte has sended\n&quot;,blocknum,rlen,flen);<br />&nbsp;&nbsp; }<br />&nbsp;&nbsp; while(true)<br />&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp; FD_ZERO(&amp;fdr);//清空集合<br />&nbsp;&nbsp;&nbsp; FD_SET(sock, &amp;fdr);//将一个给定的文件描述符加入集合之中<br />&nbsp;&nbsp;&nbsp; ret = select(sock, &amp;fdr, NULL,NULL, &amp;timeout);/*关注两个事件：数据到或时间到*/<br />&nbsp;&nbsp;&nbsp; if(SOCKET_ERROR==ret)<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;Socket error \n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp; fclose(file);<br />&nbsp;&nbsp;&nbsp;&nbsp; record(7,&amp;sour_addr,filename);<br />&nbsp;&nbsp;&nbsp;&nbsp; return;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp; if(0==ret)<br />&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(MAX_RETRY==retry)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;Time Out \n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose(file);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = makeerr(Time_out,send_buffer);//超时。发相应的error包<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sendto(sock,send_buffer,len,0,(sockaddr *)&amp;sour_addr,sizeof(sour_addr));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;超时。***DATA#%d 大小为%d byte，%d byte has sended\n&quot;,blocknum,rlen,flen);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record(8,&amp;sour_addr,filename);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sendto(sock,send_buffer,len,0,(sockaddr *)&amp;sour_addr,sizeof(sour_addr));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retry++;<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp; {//select为正值：某些文件可读写或出错<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retry = 0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sour_len = sizeof(sockaddr);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = recvfrom(sock,recv_buffer,sizeof(recv_buffer),0,(sockaddr *)&amp;sour_addr,&amp;sour_len);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //返回值:成功则返回接收到的字符数,失败返回-1.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(TFTP_ACK==recv_buffer[1])<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lastack = MAKEWORD(recv_buffer[2],recv_buffer[3]);//(新变量的低字节,高字节)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch(stat)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case TFTP_WSTAT_NEXTACK:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(blocknum==lastack&amp;&amp;rand()%100&gt;=2)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {//接收方向噪音：程序中收到数据包后作判断，rand()%100&lt;2则丢弃收到的数据报(else)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rlen = fread(data_buffer,1,512,file);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flen = flen + rlen;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(rlen&lt;512 &amp;&amp; feof(file))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stat = TFTP_WSTAT_LASTACK;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(ferror(file))<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;Error: read file\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose(file);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //发送error包<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = makeerr(Read_file_Error,send_buffer);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sendto(sock,send_buffer,len,0,(sockaddr *)&amp;sour_addr,sizeof(sour_addr));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record(6,&amp;sour_addr,filename);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //if(rlen!=0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blocknum++;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(blocknum &gt; 65535)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blocknum = 0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = makedata(blocknum,data_buffer,rlen,send_buffer,sizeof(send_buffer));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sendto(sock,send_buffer,len,0,(sockaddr *)&amp;sour_addr,sizeof(sour_addr));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printf(&quot;%d byte has sended\n&quot;,flen);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //printf(&quot;***DATA#%d&nbsp;&nbsp;  %d byte has sended，目前总共%d byte has sended\n&quot;,blocknum,rlen,flen);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //}<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;超时重发***DATA#%d:&nbsp;&nbsp;  %d byte，%d byte has sended\n&quot;,blocknum,rlen,flen);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wrong++;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retry = 0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sendto(sock,send_buffer,len,0,(sockaddr *)&amp;sour_addr,sizeof(sour_addr));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case TFTP_WSTAT_LASTACK:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(lastack==blocknum)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;\n传输结束\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(flen!=0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;total %d byte sended,信道有%d次出错,传输差错率为%.2f%%\n&quot;,flen,wrong,(float)(wrong*51200)/flen);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;total %d byte sended\n&quot;,flen);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record(4,&amp;sour_addr,filename);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retry = 0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sendto(sock,send_buffer,len,0,(sockaddr *)&amp;sour_addr,sizeof(sour_addr));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;Error LASTACK Number***DATA#%d:&nbsp;&nbsp;  %d byte，%d byte has sended\n&quot;,blocknum,rlen,flen);<br />&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default :<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; }<br /> <br />}<br />//WRQ(客户端要上传文件)<br />void upload(struct sockaddr_in sour_addr,char buffer[])<br />{<br /> char send_buffer[1024] = {0};<br /> char recv_buffer[1024] = {0};<br /> </p><p> struct  timeval timeout = {10,0};<br /> int sour_len = 0;<br /> int ret = 0;<br /> int len = 0;<br /> int flen = 0;</p><p> fd_set  fdr;</p><p> unsigned short lastdata = 0;<br /> unsigned short blocknum = 0;</p><p> FILE *file;<br /> char filename[256];<br /> </p><p> strcpy(filename,buffer+2); /*获取文件名*/</p><p> </p><p><br /> <br /> if((file=fopen(filename,&quot;rb&quot;))!=NULL){<br />&nbsp;&nbsp; //发送一个error包,报告存在同名文件<br />&nbsp;&nbsp; len = makeerr(File_already_exists,send_buffer);<br />&nbsp;&nbsp; ret = sendto(sock,send_buffer,len,0,(sockaddr *)&amp;sour_addr,sizeof(sour_addr));<br />&nbsp;&nbsp; record(9,&amp;sour_addr,filename);<br />&nbsp;&nbsp; return; <br />&nbsp;&nbsp; /*printf(&quot;File %s already exits,overwrite? y/n &quot;,filename);<br />&nbsp;&nbsp; while(true){<br />&nbsp;&nbsp;&nbsp; c = getch();<br />&nbsp;&nbsp;&nbsp; if('y'==c || 'Y'==toupper(c)){<br />&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp; fclose(file);<br />&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else<br />&nbsp;&nbsp;&nbsp;&nbsp; if('n'==c || 'N'==toupper(c)){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose(file);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; }*/<br /> }<br /> if((file=fopen(filename,&quot;w+b&quot;))==NULL){<br />&nbsp;&nbsp; printf(&quot;Can't create file\n&quot;);<br />&nbsp;&nbsp; //发送error包<br />&nbsp;&nbsp; len = makeerr(Cannot_create_file,send_buffer);<br />&nbsp;&nbsp; ret = sendto(sock,send_buffer,len,0,(sockaddr *)&amp;sour_addr,sizeof(sour_addr));<br />&nbsp;&nbsp; record(9,&amp;sour_addr,filename);<br />&nbsp;&nbsp; return;<br /> }<br /> <br /> len = makeack(blocknum,send_buffer,sizeof(send_buffer));</p><p> blocknum++;</p><p> ret = sendto(sock,send_buffer,len,0,(sockaddr *)&amp;sour_addr,sizeof(sour_addr));<br /> <br /> while(true){<br />&nbsp;&nbsp; FD_ZERO(&amp;fdr);<br />&nbsp;&nbsp; FD_SET(sock, &amp;fdr);</p><p>&nbsp;&nbsp; ret = select(sock, &amp;fdr, NULL,NULL, &amp;timeout);<br />&nbsp;&nbsp;<br />&nbsp;&nbsp; if(SOCKET_ERROR==ret){&nbsp;&nbsp; /*#define SOCKET_ERROR&nbsp;&nbsp;  (-1)*/<br />&nbsp;&nbsp;&nbsp; printf(&quot;Socket error \n&quot;);<br />&nbsp;&nbsp;&nbsp; fclose(file);<br />&nbsp;&nbsp;&nbsp; record(7,&amp;sour_addr,filename);<br />&nbsp;&nbsp;&nbsp; return;<br />&nbsp;&nbsp; }<br />&nbsp;&nbsp; else{ <br />&nbsp;&nbsp;&nbsp; if(0==ret){<br />&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;Time Out \n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp; fclose(file);<br />&nbsp;&nbsp;&nbsp;&nbsp; record(8,&amp;sour_addr,filename);<br />&nbsp;&nbsp;&nbsp;&nbsp; return;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; else{<br />&nbsp;&nbsp;&nbsp;&nbsp; if (FD_ISSET(sock,&amp;fdr)){</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sour_len = sizeof(sockaddr);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ret = recvfrom(sock,recv_buffer,sizeof(recv_buffer),0,(sockaddr *)&amp;sour_addr,&amp;sour_len);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(TFTP_DATA==recv_buffer[1]){<br />&nbsp;&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lastdata = MAKEWORD(recv_buffer[3],recv_buffer[2]);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(lastdata == blocknum){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = makeack(blocknum,send_buffer,sizeof(send_buffer));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blocknum++;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(blocknum &gt; 65535)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; blocknum = 0;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sendto(sock,send_buffer,len,0,(sockaddr *)&amp;sour_addr,sizeof(sour_addr));</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(ret &lt; TFTP_NOTEND_DATALEN){<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fwrite(&amp;recv_buffer[4],1,ret-4,file);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flen = flen + ret -4;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fclose(file);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; record(2,&amp;sour_addr,filename);</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;\n传输结束\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;total %d byte received\n&quot;,flen);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fwrite(&amp;recv_buffer[4],1,512,file);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flen = flen + 512;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if((ret-4)!=0)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;%d byte has received\n&quot;,flen);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if(lastdata == blocknum)<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;Blocknum Error!\n&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sendto(sock,send_buffer,len,0,(sockaddr *)&amp;sour_addr,sizeof(sour_addr));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }//end if(TFTP_DATA==recv_buffer[1])<br />&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp; }<br /> }<br />}</p> </div>